{
  "title": "Ideas I Own",
  "cells": [
    {
      "type": "markdown",
      "data": "## Complexity for Simplicity's Sake\nProgramming languages offer some set of syntax that attempts to aid in **the communication of ideas via code**. Some aim for a small set of syntax (Go), while others larger (Scala, Rust). The size and coverage of these sets is an intentional language design decision, and as such can be evaluated against some empirical success criteria**.\n\nFurther, the art of software engineering attempts to further aid the communication of ideas via code **in light of real-world constraints** -- engineering turnover, changing priorities, feature requests, and disparate skillsets, to name some.\n\nTherefore, I choose a success criteria for both languages as well as written software as such: **code should minimize the burden of communicating and evolving ideas over time.**\n\nWhy focus on communication and evolution? In order to generate new features and grow a product, an idea must _first_ be communicated. Only after that communication can the idea be evolved. This is the heart of software engineering in light of real-world constraints.\n\n> Side note: framing this as a minimization problem admits up front that this transfer burden is inherent in software engineering. Software deals in a complex problem space -- a mindset of maximization smacks too much of toxic \"10x engineer\" ideas.\n\nWhat increases the burden of communication and evolution over time? Lots of things, but I focus on two sources here:\n1) Complexity of primitives\n2) Complexity of aggregations\n\nI define **primitives** as a language's building blocks, its most-encountered building blocks (\"most-encountered\" being an empirical question). Simple examples include `if`, `goto`, `for`.\n\nI define **aggregations** as a set of executed primitives that come together as some named, higher-level idea to be communication. Examples include functions, classes, and even types in a suitably expressive type system (Scala).\n\nComplex primitives clearly increase the burden of communication and evolution. A simple primitive is `if` -- we deal with this decision-making every day. A complex primitive is Go's `defer` -- one must understand scope at a minimum. The idea of a `monad` is also a complex primitive -- allowing certain semantics over content and context is useful, but hard to grok.\n\nComplex aggregations also increase the burden of communication an evolution. A poorly-defined, wide-open interface brings with it massive surface area for the end user to understand. Functions with lots of input parameters require careful parsing of each one's mutations and even side effects.\n\nHere's the key idea. Aggregates are composed of primitives -- we therefore must ask whether a set of primitives tends to produce either simple or complex aggregates. **If a set of simple primitives tends to produce complex aggregates, we cannot consider those primitives to be simple.**\n\nThis is a stark way of phrasing an identical, more neutral point -- primitives cannot be considered in isolation.\n\nLet's take as an example the \"tagless final\" style of functional programming, as one writes it in Scala. Few would dispute that the primitives involved in this programming style are complex -- one must understand basic category theory, higher-kinded types, monadic transformers, and so on.\n\nHOWEVER. If the pedagogical overhead to this style is minimized -- a totally separate and extremely intimidating question -- a junior software engineer may be able to use these complex primitives to construct quite readable and evolvable aggregates.\n\nConversely, the example of Go's minimal vocabulary. Go offers pretty full exposure to value vs. pointer semantics, mutability, and is (pre-2.0) completely devoid of collections methods, which are enabled by also-missing generics. This can lead to code with highly-nested, side-effect-ridden code that requires an extremely granular understanding of the codebase. This granular understanding must then be upgraded into a higher-level understand -- for example, lots of loops and assignment can upgrade into a basic \"getOrElse\" type of semantic.\n\nUltimately, this is a question of up-front versus long-term costs in software engineering. I'm no fanboy of either Scala or Go, but they do offer extremely different takes of these costs (no matter how much Odersky groans about a \"small working set\" in his keynotes).\n\nI stake my claim as such: I prefer some small up-front costs that allow for greater long-term communication and evolution of ideas. I think that this is all we really do in programming -- learn what a `for` loop is, learn about functions and methods. We're tacitly saying, \"if you invest in this vocabulary, you'll be more successful in the long-term\".\n\nThe conversation, however, mysteriously stops past your basic programming education in `if` and `for` -- it should not. Simple primitives are not a pure virtue, nor complex ones a vice. Simple primitives can lead to monstrous aggregates that extract a much higher burden of communication and evolution."
    }
  ]
}