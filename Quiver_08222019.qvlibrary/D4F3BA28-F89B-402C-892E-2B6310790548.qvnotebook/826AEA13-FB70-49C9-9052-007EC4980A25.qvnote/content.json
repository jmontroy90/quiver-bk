{
  "title": "Envoy - Overview",
  "cells": [
    {
      "type": "markdown",
      "data": "Envoy is a L4 proxy that can act like L7 with swappable middleware for upgrading a raw TCP / UDP to something more intelligent. \n\nA brief refresher / learner on this topic is in order.\n\n[Introduction to modern network load balancing and proxying](https://blog.envoyproxy.io/introduction-to-modern-network-load-balancing-and-proxying-a57f6ff80236)\n\nLoad Balancers / Proxies (term is overloaded) cover three responsibilities:\n\n1) **Service discovery**: What backends are available in the system? What are their addresses (i.e., how should the load balancer talk to them)?\n2) **Health checking**: What backends are currently healthy and available to accept requests?\n3) **Load balancing**: What algorithm should be used to balance individual requests across the healthy backends?\n\nClients (\"downstreams\") not having to know exact details of current network topology (\"which hostnames / IPs correspond to this named service?\") is extremely beneficial! This also leaves room for fault tolerance and performance optimizations (with management of over / undersubscription).\n\n> over/undersubscription refers to the amount of bandwidth consumable via NICs as a percentage of bandwidth available between routers\n\n### L4 vs L7 Proxies\n**L4** is _roughly_ at layer 4 of the OSI model, which manages traffic via TCP / UDP. This means there's no understanding of raw bytes sent to a proxy -- HTTP, Redis, it's all the same. An L4 proxy will receive a client connection, terminate it (respond to `SYN`), then open a new connection to the appropriate backend based on load and network topology, etc.\n\n![IMAGE](quiver-image-url/F9D8C565F7A809F6C3FAF2915B8890E8.jpg =1600x252)\n\n**L7** allows for more intelligent handling of requests. For instance, HTTP/2 connections can be multiplexed (two streams sending requests over the same connection), and an L7 proxy will understand that and divvy up load to upstreams appropriately.\n\n![IMAGE](quiver-image-url/8541C998E5FC2658FB3D4ECEC8AE4604.jpg =1600x650)\n\nBear in mind that L7 encompasses a _lot_:\n* Optional Transport Layer Security (TLS)\n* Physical HTTP protocol (HTTP/1 or HTTP/2)\n* Logical HTTP protocol (headers, body data, and trailers)\n* Messaging protocol (gRPC, REST, etc.)\n\n\nSome terms to define more through this article and others:\n* Middle proxy\n* Edge proxy\n* Sidecar proxy\n* Embedded client library\n* Connection tracking\n* NAT\n* Direct server return (DSR)\n* virtual IPs (VIP)\n* Equal-cost multi-path routing (ECMP)\n* Global load balancing and a split between the control plane and the data plane\n\n* TCP/UDP termination load balancers\n* TCP/UDP passthrough load balancers\n\n# Control Plane / Data Plane / Service Plane\n[Link to article](https://blog.envoyproxy.io/service-mesh-data-plane-vs-control-plane-2774e720f7fc)\n\nResponsibilities of the data plane:\n* Service discovery\n* Health checking\n* Routing\n* Load balancing\n* Authentication and authorization\n* Observability\n\nAll of these responsibilities are traditionally managed via static configuration, pushed out by some human running their automation scripts.\n\nA control plane replaces human management of config. A cluster manager / workload schedular (Kubernetes, Nomad) allocates instances of services - service discovery information then makes its way to the sidecar proxies in an eventually consistent way such that routing and config works correctly.\n\nIn short -- the data plane performs the above responsibilities by touching each and every packet, using its current configuration. It gets its current configuration in an eventually consistent way from the control plane.\n\nIstio is a platform for your service mesh's control plane. HAProxy and Envoy are just sidecar proxies that each manage their data plane.\n\nControl planes are decoupled from data planes, which is good! For example, Istio has integrations with Envoy, Linkerd, and Nginx.\n\n# Embracing Eventual Consistency\n[Link to article](https://blog.envoyproxy.io/embracing-eventual-consistency-in-soa-networking-32a5ee5d443d)\n\nDatabases are tending backs towards highly distributed, strongly consistent, and transaction-based stores -- Spanner is the forerunner here by far.\n\nWhy does Envoy offer eventual consistency for the SoA world? For auto-scaling, CICD-oriented, stateless services, the infrastructure is always changing. Coordination is hard, so forget it.\n\nYes, you can force Envoy into a state where it returns 503s based on its eventual consistency. But you'd be simulating an artificial test case that no one actually does when scaling architecture.\n\nBut if you REALLY need strong consistency, ADS is available - you just have to code it yourself.\n\nWe use ADS for Nebula. Not sure why.\n\n# Envoy's gRPC + Protobuf v2 API\n[Link to article](https://blog.envoyproxy.io/evolving-a-protocol-buffer-canonical-api-e1b2c2ca0dec)\n\nThe v1 API was REST-JSON polling-based, and v2 moved to gRPC. Protobuf has a well-defined JSON canonical mapping, well-defined evolution rules, support for more advanced type annotations (\"must be non-zero\", \"must have a length < 50\"), and support for generated documentation from comments.\n\nEnvoy makes use of Proto's `Any` type a whole lot - they got burned when using this in tandem with package namespace moves. JSON incompatibility and consuming API breaks also causes concern with \"field rename considered harmless\" mentalities (a field rename seems okay for the wire format, but it's not for other representations).\n\n\"Design the package namespace hierarchy carefully upfront.\"\n\n"
    }
  ]
}