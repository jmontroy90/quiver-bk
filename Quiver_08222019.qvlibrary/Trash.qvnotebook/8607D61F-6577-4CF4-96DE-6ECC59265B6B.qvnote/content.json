{
  "title": "Untitled Note",
  "cells": [
    {
      "type": "latex",
      "language": "latex",
      "data": "\\!\n| \\gEverything You Always Wanted to Know About Pattern Matching* \n| \\g(*But Were Afraid to Ask)\n\n| @lutzhuehnken\n\n\n| Lightbend\n---\n| Pattern Matching\n\n```\nexpr match {\n  case pattern1 => result1\n  case pattern2 => result2\n}\n```\n\nDifferences to Java switch:\n* It’s an expression \n* No fall-through\n* MatchError if there’s no match\n\n\n---\n\n\n```\n case pattern => result\n\n```\n\n* case is followed by a pattern\n* pattern must be one of the legal pattern types\n* result is an arbitrary expression\n* if pattern matches, result will be evaluated and returned\n\n---\n\n```\ndef matchAll(any: Any): String = any match {\n  case _ => \"It’s a match!\"\n}\n\n```\nWildcard Pattern\n* _ matches anything\n* use as „default“ (remember MatchError)\n\n---\n\n```\ndef isIt8(any: Any): String = any match {\n  case \"8:00\" => \"Yes\"\n  case 8 => \"Yes\"\n  case _ => \"No\"\n}\n```\n\nConstant Pattern\n\n---\n\n```\ndef matchX(any: Any): String = any match {\n  case x => s\"He said $x!\"\n}\n```\n\nVariable Pattern \n* identifier  - also matches anything!\n\n---\n\nVariables vs. Constants\n\n```\n  import math.Pi\n\n  val pi = Pi\n\n  def m1(x: Double) = x match {\n    case Pi => \"Pi!\"\n    case _ => \"not Pi!\"\n  }\n\n  def m2(x: Double) = x match {\n    case pi => \"Pi!\"\n    case _ => \"not Pi!\"\n  }\n\n```\n\n\n---\n\n| Attention!\n\n* uppercase - compiler will assume it's constant\n\n* lowercase - compiler will assume it's a new \n  identifier (local to the match expression)!\n\n| This is a very common source of errors!\n---\n\n\nLet's fix this!\n\n```\n  import math.Pi\n\n  val pi = Pi\n\n  def m3(x: Double) = x match {\n    case this.pi => \"Pi!\"\n    case _ => \"not Pi!\"\n  }\n\n  def m4(x: Double) = x match {\n    case `pi` => \"Pi!\"\n    case _ => \"not Pi!\"\n  }\n\n\n```\n\n---\n\nTo refer to lowercase values\n\n* use qualified name (e.g. this.pi) or\n\n* use backticks (e.g. `pi`)\n\n---\n\nConstructor Pattern (Case Classes)\n\n```\ncase class Time(hours: Int = 0, minutes: Int = 0)\nval (noon, morn, eve) = (Time(12), Time(9), Time(20))\n\ndef mt(t: Time) = t match {\n  case Time(12,_) => \"twelve something\"\n  case _ => \"not twelve\"\n}\n```\n\n---\n\nNest it like crazy\n\n```\ncase class House(street: String, number: Int)\ncase class Address(city: String, house: House)\ncase class Person(name: String, age: Int, address: Address)\n\nval peter = Person(\"Peter\", 33, Address(\"Hamburg\", House(\"Reeperbahn\", 45)))\nval paul = Person(\"Paul\", 29, Address(\"Berlin\", House(\"Oranienstrasse\", 64)))\n\ndef m45(p: Person) = p match {\n  case Person(_, _, Address(_, House(_, 45))) => \"Must be Peter!\"\n  case Person(_, _, Address(_, House(_, _))) => \"Someone else\"\n}\n```\n\n---\n\nSequence Pattern\n\n```\nval l1 = List(1,2,3,4)\nval l2 = List(5)\nval l3 = List(5,8,6,4,9,12)\n\ndef ml(l: List[Int]) = l match {\n  case List(1,_,_,_) => \"starts with 1 and has 4 elements\"\n  case List(5, _*) => \"starts with 5\"\n}\n```\n\n---\nSequence Pattern (cont'd)\n\n```\nimport annotation._\n\n@tailrec\ndef contains5(l: List[Int]): String = l match {\n  case Nil => \"No\"\n  case 5 +: _ => \"Yes\"\n  case _ +: tail => contains5(tail)\n}\n```\n---\nSequence Pattern (cont'd)\n\n```\n@tailrec\ndef contains5(l: List[Int]): String = l match {\n  case Nil => \"No\"\n  case 5 +: _ => \"Yes\"\n  case _ +: tail => contains5(tail)\n}\n```\n\nQuiz: What is \"+:\"?\n\n---\nIt's an extractor! \nYou can navigate to the source code in your IDE.\nSlightly simplified:\n\n```\n/** An extractor used to head/tail deconstruct sequences. */\nobject +: {\n  def unapply[A](t: Seq[A]): Option[(A, Seq[A])] =\n    if(t.isEmpty) None\n    else Some(t.head -> t.tail)\n}\n```\n---\nExtractor\n\n* An extractor is a Scala object with an unapply() method.\n* Think unapply() is \"dual\" of apply()\n* unapply takes the value you match on as parameter (if the type matches)\n* return something (we'll look into that)\n* the returned is matched with your pattern\n---\nExtractor (cont'd)\n\nLet's write our own.\n\n```\ncase class Time(hours: Int = 0, minutes: Int = 0)\nval (noon, morn, eve) = (Time(12), Time(9), Time(20))\n\nobject AM {\n  def unapply(t: Time): Boolean = t.hours < 12\n}\n\ndef greet(t:Any) = t match {\n  case AM() => \"Good Morning!\"\n  case _ => \"Good Afternoon!\"\n}\n```\n\n---\n\nWith variable binding.\n\n```\n\nobject AM {\n  def unapply(t: Time): Option[(Int,Int)] = \n    if (t.hours < 12) Some(t.hours -> t.minutes) else None\n}\n\ndef greet(t:Time) = t match {\n  case AM(h,m) => f\"Good Morning, it's $h%02d:$m%02d!\"\n  case _ => \"Good Afternoon!\"\n}\n```\n\n---\n\nJust for demo purposes:\nif we return a pair, we can write the extractor inline..\n\n```\n\nobject AM {\n  def unapply(t: Time): Option[(Int,Int)] = \n    if (t.hours < 12) Some(t.hours -> t.minutes) else None\n}\n\ndef greet(t:Time) = t match {\n  case _ AM _ => \"Good Morning!\"\n  case _ => \"Good Afternoon!\"\n}\n```\n\n---\n\nIn case you still have doubts..\n\n```\nimport annotation._ \n\nval l1 = List(1,2,3,4)\nval l2 = List(5)\nval l3 = List(5,8,6,4,9,12)\n\n@tailrec\ndef contains5(l: List[Int]): String = l match {\n  case Nil => \"No\"\n  case +:(5, _) => \"Yes\"\n  case +:(_, tail) => contains5(tail)\n}\n```\n\nMystery of +: solved completely. It's simple ;)\n\n---\n* yes/no - return Boolean\n* 2 or more variables - return Option[TupleN[..]]\n* 1 variable? There's no 1-tuple...\n\n```\ncase class Time(hours: Int = 0, minutes: Int = 0)\nval (noon, morn, eve) = (Time(12), Time(9), Time(20))\n\nobject AM {\n  def unapply(t: Time) = if (t.hours < 12) Some(t.hours) else None\n}\n\ndef greet(t:Time) = t match {\n  case AM(h) => s\"Good Morning, the hour is $h!\"\n  case _ => \"Good Afternoon!\"\n}\n```\n\n---\n\nTypes..\n\n```\ndef greet(t:Any) = t match {\n  case AM(h) => s\"Good Morning, the hour is $h!\"\n  case _: Time => \"Good Afternoon!\"\n}\n```\n---\n\nExtractors\n\n* What goes in?\n--\n* Your match value\n* Where is it defined?\n--\n* unapply() in your extractor object\n* what is returned?\n--\n* No variables: Boolean\n* One variable: Option[A]\n* N variables: Option[TupleN[..]]\n--\n* It gets even better!\n\n---\n\nSay, I don't want to allocate an Option & Tuple every time I match.\nLet's just \"pretend\" we are an Option[TupleN[..]]\n\n```\ncase class Time(hours: Int = 0, minutes: Int = 0) {\n  def isEmpty = false\n  def get = this\n  def _1 = hours\n  def _2 = minutes\n}\n\nval noTime = new Time { override def isEmpty = true }\n\nobject AM {\n  def unapply(t: Time): Time = if (t.hours < 12 ) t else noTime\n}\n\ndef isAM(t:Time) = t match {\n  case AM(h,m) => f\"Good Morning, it's $h%02d:$m%02d!\"\n  case _ => \"Good Afternoon!\"\n}\n```\n\n---\n\n* This concept is called name based extractors\n* It was introduced in Scala 2.11\n* It's an optimization, it might not make your code more readable\n* Remember: Premature optimization is the root of all evil!\n\n---\nDo's and don'ts\n\n```\nimport collection.immutable.Seq\n\ndef contains5(l: Seq[Int]): String = l match {\n  case Nil => \"No\"\n  case 5 :: _ => \"Yes\"\n  case _ :: tail => contains5(tail)\n}\n```\n\nQuiz: What's wrong with this?\n\n---\n\n:: is a case class, the second class parameter is a List.\nYou can navigate to the source code in your IDE.\nSlightly simplified:\n\n```\ncase class ::[B](head: B, tl: List[B]) extends List[B] {\n  override def tail : List[B] = tl\n  override def isEmpty: Boolean = false\n}\n```\n---\n\nDo's and don'ts\n\n* :: takes an element and a List\n* +: takes an element and a Seq\n\n* :: may look prettier than +:, but you might want to\n  play it safe and use +: just in case.\n\n* by the way, what about :+ ?\n\n---\n\nDo's and don'ts\n\n```\ndef contains5(l: List[Int]): String = l match {\n  case Nil => \"No\"\n  case _ :+ 5 => \"Yes\"\n  case init :+ _ => contains5(init)\n}\n```\n\nAlthough that may work, it may be very inefficient.\n\n---\n\nGetting deep insights..\n\n```\ncase class Time(hours: Int = 0, minutes: Int = 0)\nval (noon, morn, eve) = (Time(12), Time(9), Time(20))\n\ndef checkTwice(x: Any): String = x match {\n  case Time(h,m) if h > 11 => \"Too late for breakfast\"\n  case Time(h,m) if h < 7 => \"Too early\"\n  case _ => \"undefined is not a function\"\n}\n```\n\n---\n\n$ scala -Xshow-phases\n    phase name  id  description\n    ----------  --  -----------\n        parser   1  parse source into ASTs, perform simple desugaring\n         namer   2  resolve names, attach symbols to named trees\npackageobjects   3  load package objects\n         typer   4  the meat and potatoes: type the trees\n\\c        patmat   5  translate match expressions\nsuperaccessors   6  add super accessors in traits and nested classes\n    extmethods   7  add extension methods for inline classes\n       pickler   8  serialize symbol tables\n     refchecks   9  reference/override checking, translate nested objects\n       uncurry  10  uncurry, translate function values to anonymous classes\n     tailcalls  11  replace tail calls by jumps\n     ... and so on until 25\n\n\n---\n\n$ scala -Xprint:patmat\n\n* It's not super readable\n* But if you know what you look for, \n  you might find it.\n* Play around with printing other phases, too!\n\n---\n\nCase classes\n\n* While we still have the output on, let's check..\n\n```\ncase class T2(p1 : Int, p2: Int)\n\ncase class T23(p1 : Int, p2: Int, p3: Int, p4: Int, p5: Int,\n  p6: Int, p7: Int, p8: Int, p9: Int, p10: Int,\n  p11: Int, p12: Int, p13: Int, p14: Int, \n  p15: Int, p16: Int, p17: Int, p18: Int, \n  p19: Int, p20: Int, p21 : Int, p22: Int, p23: Int)\n```\n\n---\n\n```\nval t2 = T2(1,2)\nval t23 = T23(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)\n\ncase class T2(p1 : Int, p2: Int)\n\ndef m(x: Any) = x match {\n  case T2(_,_) => \"T2\"\n  case T23(1,2,3,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_) \n    => \"What? How did this work?\"\n  case _ => \"undefined is not a function\"\n}\n\n---\n\nCase Classes\n\n* For case classes, the unapply() method is not used!\n* Positive side effect: You can pattern match \n  on case classes with > 22 fields.\n\n---\n\nStill more on extractors..\n\nWhat if you don't know the number of variables?\n\n\n---\n\nExample..\n\n```\nval s1 = \"lightbend.com\"\nval s2 = \"www.scala-lang.org\"\n\nobject Domain {\n\tdef unapplySeq(s: String) = Some(s.split(\"\\\\.\").reverse)\n}\n\ndef md(s: String) = s match {\n\tcase Domain(\"com\", _*) => \"business\"\n\tcase Domain(\"org\", _*) => \"non-profit\"\n}\n\n```\n\n---\n\nSecret sauce: unapplySeq\n\n* Let's you return variable number of values\n* Think dual apply with varargs\n* Also: Some values and then sequence\n* apply where last argument is varargs\n\n---\n\nBy the way, scala.util.matching.Regex provides an unapplySeq method\n\n```\nval pattern = \"a(b*)(c+)\".r\nval s1 = \"abbbcc\"\nval s2 = \"acc\"\nval s3 = \"abb\"\n\ndef mr(s: String) = s match {\n  case pattern(a, bs) => s\"\"\"two groups \"$a\" \"$bs\"\"\"\"\n  case pattern(a, bs, cs) => s\"\"\"three groups \"$a\" \"$bs\" \"$cs\"\"\"\"\n  case _  => \"no match\"\n}\n\n```\n\n---\n\nBy the way, you can also use a string interpolator!\n\nDefine a \"t\" interpolator ..\n\n```\nimplicit class TimeStringContext (val sc : StringContext) {\n  object t {\n    def apply (args : Any*) : String = sc.s (args : _*)\n\n    def unapplySeq (s : String) : Option[Seq[Int]] = {\n      val regexp = \"\"\"(\\d{1,2}):(\\d{1,2})\"\"\".r\n      regexp.unapplySeq(s).map(_.map(s => s.toInt))\n    }\n  }\n}\n```\n\n---\n\n.. and use it in pattern match!\n\n\n```\ndef isTime(s: String) = s match {\n  case t\"$hours:$minutes\" => Time(hours, minutes)\n  case _ => \"Not a time!\"\n}\n```\n\n---\n\n@switch annotation\n\n```\nimport annotation._ \n\ndef wsw(x: Int): String = (x: @switch) match {\n  case 8 => \"Yes\"\n  case 9 => \"No\"\n  case 10 => \"No\"\n}\n```\n---\n\n@switch annotation (cont'd)\n\n```\nimport annotation._ \n\ndef wsw(x: Any): String = (x: @switch) match {\n  case 8 => \"Yes\"\n  case \"9\" => \"No\"\n  case \"10\" => \"No\"\n}\n```\n\nWould give a warning (outside of presentation)\n\n---\n\n@switch annotation (cont'd)\n\nVerifies that the match expression can be compiled \nto a tableswitch or lookupswitch \nand issues an error if it instead compiles \ninto a series of conditional expressions.\n\n---\n\n@switch annotation\n\n```\nimport annotation._ \n\ndef wsw(x: Any): String = (x: @switch) match {\n  case 8 => \"Yes\"\n  case 9 => \"No\"\n  case 10 => \"No\"\n}\n\n\ndef wosw(x: Int): String = x match {\n  case 8 => \"Yes\"\n  case 9 => \"No\"\n  case 10 => \"No\"\n}\n\n```\n\n---\n\nPattern matching and type erasure\n\n```\n\ndef print[A](xs: List[A]) = xs match {\n  case _: List[String] => \"list of strings\"\n  case _: List[Int] => \"list of ints\"\n}\n```\n\n---\n\nPattern matching and type erasure (cont'd)\n\n```\nimport scala.reflect._\ndef print[A: ClassTag](xs: List[A]) = classTag[A].runtimeClass match {\n  case c if c == classOf[String] => \"List of strings\"\n  case c if c == classOf[Int]    => \"List of ints\"\n}\n\n```\n---\n\nMatch by type\n```\ndef t(x:Any) = x match {\n  case _ : Int => \"Integer\"\n  case _ : String => \"String\"\n}\n```\n\n---\n\nMatch alternatives\n\n```\ndef alt(x:Any) = x match {\n  case 1 | 2 | 3 | 4 | 5 | 6 => \"little\"\n  case 100 | 200 => \"big\"\n}\n```\n\n---\n\nSimulating union types?\n\n```\n\ndef talt(x:Any) = x match {\n  case stringOrInt @ (_ : Int | _ : String) => \n    s\"Union String | Int: $stringOrInt\"\n  case _ => \"unknown\"\n}\n```\n\n--\n* Unfortunately the compile time type of stringOrInt is Any\n* No union types in Scala (yet ;)\n\n\n---\n\n\n\\!\n| \\gThank You!\n\n| @lutzhuehnken\n\n\n| Lightbend"
    }
  ]
}