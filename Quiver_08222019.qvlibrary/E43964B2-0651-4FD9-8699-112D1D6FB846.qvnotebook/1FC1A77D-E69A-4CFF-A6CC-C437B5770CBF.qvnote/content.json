{
  "title": "Strings are Evil",
  "cells": [
    {
      "type": "markdown",
      "data": "Primitives are too broad - can we use Scala techniques to make it harder / impossible to construct a bad type due to primitives?\n\n### Basic Techniques\n\n**Round 1** — make a type alias? `type UUID = String` -- this doesn't actually do anything other than give a hint to the programmer.\n\n**Round 2** — make a case class? `case class UUID(asString: String)` -- this is more type-safe, but there's no validation on the input and there's runtime overhead. Extending `AnyVal` helps, but not much.\n\n**Round 3** — make your primary constructor private, add a more intelligent `apply` method with `Option`. `copy` can escape validation though, and you might have too many `Option` types floating around.\n\n**Round 4** — `sealed abstract case class UUID(asString: String)`. Gives us a private constructor and no `copy`, but it's weird.\n\n### Functions\n\nWhen an input type is broader than the output type (e.g. `String => UUID`), you can **widen** the output type (e.g. `String => Option[UUID]`) to help with mappings. You can also **narrow** the input type (e.g. `32List[AlphaChar] => UUID`).\n\n### Refinement Types\n\n_Definition_ — a type with a predicate that is assumed to hold for all members.\n\n[Github repo with great examples here!](https://github.com/fthomas/refined)\n\nGives you compile-time safety on literals, run-time validation on values, and allows you to compose predicates!\n\n### Opaque Types\n\n`opaque type UUID = String`\n\nNot available yet, [SIP-35](https://docs.scala-lang.org/sips/opaque-types.html) has progress. \n\nThey give you compile-time type safety without runtime overhead! From the SIP:\n> The goal is that operations on these wrapper types must not create any extra overhead at runtime while still providing a type safe use at compile time.\n\nFirst off — a type alias has no actual type safety at compile time (i.e. the aliases are replaced with their actual type at compile time, which means two type aliases tethered to the same basic type can be used interchangeably):\n\n```\ntype Password = String\ntype UserName = String\n\ndef notPassword(user: UserName): Unit = {\n  if (user.isInstanceOf[UserName]) println(\"hell yea!\") else print(\"noooo!\")\n}\n\nval u: UserName = \"john\"\nval p: Password = \"secret\"\n\nnotPassword(u)\nnotPassword(p)\n```\n\nValue classes were meant to help this same problem of boxing / unboxing case classes, but they have limits; given a class boxing a `Double` called `Logarithm` and of course extending `AnyVal`, limits are:\n\n> Unfortunately, this transparent boxing is relatively easy to trigger. Some very common situations where Logarithm instances will be allocated at runtime include:\n-- use in arrays (e.g. Array[Logarithm])\n-- use in generic collections (e.g. List[Logarithm])\n-- parameters or return values of anonymous functions\n-- calling equals or hashCode on a Logarithm\n\nSyntax would just look like:\n```\npackage object opaquetypes {\n  opaque type Logarithm = Double\n}\n```\n"
    }
  ]
}