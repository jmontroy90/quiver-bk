{
  "title": "Avro spec",
  "cells": [
    {
      "type": "markdown",
      "data": "Avro:\n\n* \"A container file, to store persistent data.\" -- is this for storing writer's schema for a whole host of files?\n* \"Code generation as an optional optimization, only worth implementing for statically typed languages.\" -- code generation for F# how? For Java, fine.\n* \"No manually-assigned field IDs: When a schema changes, both the old and new schema are always present when processing data, so differences may be resolved symbolically, using field names.\" -- this is useful.\n* \"Fixed\" types - {\"type\": \"fixed\", \"size\": 16, \"name\": \"md5\"}\n* \"Aliases function by re-writing the writer's schema using aliases from the reader's schema. For example, if the writer's schema was named \"Foo\" and the reader's schema is named \"Bar\" and has an alias of \"Foo\", then the implementation would act as though \"Foo\" were named \"Bar\" when reading. Similarly, if data was written as a record with a field named \"x\" and is read as a record with a field named \"y\" with alias \"x\", then the implementation would act as though \"x\" were named \"y\" when reading.\"\n\t* This is useful for adhoc operations in schema evolution - \"can you alias this field as this so we can read it for backfills?\". Will get dicey though.\n* \"Avro-based remote procedure call (RPC) systems must also guarantee that remote recipients of data have a copy of the schema used to write that data.\"\n\t* Our use case is the \"schema version in database records\" case, which is like RPC except the remote recipients receive a copy of the schema at compile time via a registry.\n* \"Because the schema used to write data is always available when the data is read, Avro data itself is not tagged with type information. The schema is required to parse data.\" -- this is the fundamental thing. Protobuf has different means.\n* binary format - \"null is written as zero bytes.\"; strings always have a length header to the field. so do maps and arrays (for num elements)\n* \"UTF-8 is used as the binary encoding for strings\"\n\n\n> A file header consists of:\n> \n> Four bytes, ASCII 'O', 'b', 'j', followed by 1.\nfile metadata, including the schema.\nThe 16-byte, randomly-generated sync marker for this file.\nFile metadata is written as if defined by the following map schema:\n> \n> {\"type\": \"map\", \"values\": \"bytes\"}\n\n\nOn schema promotion / evolution between writer and reader:\n> The writer's schema may be promoted to the reader's as follows:\n\tint is promotable to long, float, or double\n\tlong is promotable to float or double\n\tfloat is promotable to double\n\tstring is promotable to bytes\n\tbytes is promotable to string```\n\n\n\nRecords -- this is the main thing we use:\n```\n{\n  \"type\": \"record\",\n  \"name\": \"LongList\",\n  \"aliases\": [\"LinkedLongs\"],                      \n  \"fields\" : [\n    {\"name\": \"value\", \"type\": \"long\"},             \n    {\"name\": \"next\", \"type\": [\"null\", \"LongList\"]} \n  ]\n}\n```\n\n1) Reader is unaware of a writer field - ignored\n2) Reader has a field with a default, and writer doesn't have the field - use default\n3) No default in reader, and nothing in writer - error!\n4) Logical types allow for additional field metadata to encode extra schema information - `date`, `time-millis`, `decimal` (with scale and precision). Dates are encoded purely as longs since 1970 (for days) and an int to represent millis since midnight for times.\n\nQuestions:\n1) What's the exact workflow for pulling down a schema version at compile time?\n2) If your application using schema version 1 encounters a message with newer schema 2, how does it actually resolve that? It won't have schema 2 past compile time!\n\n"
    }
  ]
}