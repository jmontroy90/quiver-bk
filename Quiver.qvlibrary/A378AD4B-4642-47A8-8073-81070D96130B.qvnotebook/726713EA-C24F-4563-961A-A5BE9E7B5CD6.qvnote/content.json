{
  "title": "Consistency and Consensus",
  "cells": [
    {
      "type": "markdown",
      "data": "Two kinds of ordering:\n* Partial ordering - either A `happens-before` B, B `happens-before` A, **OR** they happened concurrently.\n* Total ordering - every operation is ordered with respect to others, i.e. there is no concurrency. A partial order is implied by a total order (is \"stronger\", and thus contains), and a total order can be created out of a partial order:\n\n> In particular, we can create sequence numbers in a total order that is consistent with causality:vii we promise that if operation A causally happened before B, then A occurs before B in the total order (A has a lower sequence number than B). Concurrent operations may be ordered arbitrarily. Such a total order captures all the causality information, but also imposes more ordering than strictly required by causality.\n\nLamport timestamps (simply [id, nodeID] pairs) create a total order in operations, but that total order is only available for introspection and decision-making _after_ a set of concurrent operations have been finalized in a total order. In order to make game-time decisions on concurrent operations, all clients and nodes must agree on when a total order has been finalized, and this requires game-time awareness of what other operations nodes are concurrently performing.\n\nAll this to say - in order to have consistent ordering in a distributed system, you must strengthen _total order_ to **total order broadcast**.\n\nTotal order broadcast is an attempt to get what single-leader replication offers - a total order of operations - at a fault-tolerant scale in a distributed system. In order for any algorithms to work on that front, we need two guarantees from our nodes:\n1) Reliable delivery - no messages are lost\n2) Totally ordered delivery - messages from a node are delivered in the same order to all receiving nodes \n\nTotal broadcast order and linearizability are interchangeable, and both are a form of creating consensus in distributed systems! So to get their power, we need a a consensus algorithm like **two-phase commit**.\n\nTo start - a consensus algorithm helps implement atomic commit - either an operation succeeds on all nodes, or it's rolled back on all nodes. A first stab at this is via two-phase commit, which is not a great algorithm but is a good starting point for things like Zab and Raft.\n\n(Contine from: Distributed Transactions in Practice)"
    }
  ]
}