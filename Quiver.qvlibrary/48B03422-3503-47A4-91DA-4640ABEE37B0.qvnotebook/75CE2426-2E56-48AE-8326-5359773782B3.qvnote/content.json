{
  "title": "Chapter 4: Health Probe",
  "cells": [
    {
      "type": "markdown",
      "data": "Health checks go beyond simple process status codes. OOMs, thrashing, deadlocks - they can all cause hung, frozen applications. How do we check health robustly?\n\n#### Process Health Checks\nSimple checks performed by a node's `kubelet` to see if container processes are running. Sufficient for basic cases.\n\n#### Liveness Probes\nIF your program is deadlocked, thrashing, hung, or whatever, the process health check is insufficient. Liveness probes check for these bad states with things like:\n\n> HTTP probe performs an HTTP GET request to the container IP address and expects a successful HTTP response code (2xx or 3xx).\n\n> A TCP Socket probe assumes a successful TCP connection.\n\n> An Exec probe executes an arbitrary command in the container kernel namespace and expects successful exit code (0).\n\nExamples in the Kubernetes YML:\n```\n...\nlivenessProbe:\n    httpGet:                    1\n      path: /actuator/health\n      port: 8080\n    initialDelaySeconds: 30 \n...\n```\n#### Readiness Probes\ntl;dr - when is your application ready to serve live requests? This buys you time while your app spins up - maybe it indicates readiness with the creation of a file on the local filesystem:\n```\n...\nreadinessProbe:\n  exec:\n    command: [ \"stat\", \"/random-generator-ready\" ]\n```\n\nBear in mind that the readiness check only applies to start-up -- once a container receives a SIGTERM, Kubernetes will try to shut off traffic to that container regardless of the readiness check.\n\n#### Discussion\nA microservices architecture builds in a level of agnosticism about its actual services -- that is, stateless over stateful. But if that's your first principle, you need to ramp up your observability to make up for the black-box nature of your architecture. This includes a couple components:\n* Logging (stdout, stderr) to a centralized source (Splunk)\n* Metrics (Prometheus, New Relic)\n* Liveness Probe\n* Readiness Probe\n\nAdditionally, it's not a bad idea to include a termination log (e.g. `/dev/termination-log`) that contains all exit codes and reasons for containers (a \"last will\" of sorts).\n\n![IMAGE](quiver-image-url/F1574CE57AF4FF3B2A68D3D5735AFB70.jpg =1270x391)\n\n\n"
    }
  ]
}