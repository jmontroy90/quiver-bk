{
  "title": "Chapter 2: Language Syntax",
  "cells": [
    {
      "type": "markdown",
      "data": "## 2.1 - Variables\n\n* Go zero-initializes all variables. The `var` syntax indicates that, whereas the `:=` syntax indicates both initialization and assignment.\n* Go uses conversions over casts - casts are a raw interpreting of bytes as new type `A` (regardless of their current type), whereas conversions will allocate new bytes corresponding to new type `A` and copy the original value over into that. This is safer and has \"integrity\".\n* Conversions look like: `int32(i1)`.\n\n## 2.2 - Struct Types\n\n* \"We create values in Go, not objects.\"\n* You can create struct types with their zero values in Go. How those get displayed come down to the `fmt` flags you use.\n* Structs are allocated according to both the constituent types AND by byte alignment; e.g. smaller types will require byte padding when succeeded by larger types:\n    * `[bool| | | ][i32|i32|i32|i32]`\n* You COULD order your struct type fields from largest to smallest to eliminate byte padding, but that concern is far and away trumpted by semantic clarity. Group things correctly.\n* Bear in mind literal structs vs. named structs. Named structs are the ones declared with `type your_struct struct { ... }`, whereas literal structs are basically anonymous. Refresh syntax if needed.\n* Named structs cannot be implicitly converted between one another (they must be explicitly converted), but literal structs CAN be implicitly converted. This makes sense - you're just naming your allocations, there's no loss of information.\n\n## 2.3 - Pointer (pass-by-value)\n### Part 1\n* Stack memory allocated to goroutines is much smaller than that allocated to OS threads (2k < 1M)\n* When goroutines execute a function, they allocate a stack frame for themselves off the stack memory.\n* All variables are passed to functions by value in the basic case. This means **a copy of the data** is passed to the called function's stack frame, where that new value has a new location on the stack in the function's stack frame.\n* This makes Go's default operations immutable and isolated. But what if we wanna share data across stack frame boundaries?!?\n### Part 2\n* If we want to share data across frame boundaries, we use pointers, e.g. the `*` notation. Do exercises to get used to this!\n* The `*` dereferences a pointer, and `&` gives its address (per usual). Remember that address size depends on CPU architecture.\n* When you see a pointer, think mutability! Think side effects! Think statefulness! e.g. this is all a little scary.\n### Part 3\n* If you try to pass a pointer up the stack, the Go compiler's escape analysis will allocate the pointer on the stack and its value on the **heap**.\n* Heap values are accessed via pointers, but Go lets us access heap values with value semantics, dereferencing without having us know.\n* `return &u` indicates a stack pointer being returned up the stack to refer to a value allocated on the heap.\n* Pointer semantics on construction is confusing unless the pointer is being returned OR passed in somewhere directly in the same expression.\n### Part 4\n* Compilers can allocate things on the stack safely by knowing variable sizes at compile time -- int32, bool, all known. Of course, things like collections and strings (sequence of chars) can grow arbitrarily large, so they have to be allocated on the heap at runtime.\n* Go has contiguous stacks - when you run out of stack space, a new stack that's 25% larger than the current stack is allocated, and all frames are moved over to that stack. That's neat! But it means your stack data can move around at runtime.\n* Stack memory CANNOT be shared across goroutines. The heap is the place for:\n    * Shared data\n    * Data that escapes its frame due to integrity issues\n    * Data whose size isn't known at compile time\n### Part 5\n* Go's heap GC is NOT compacting - it doesn't move objects around.\n* It is a: _tri-color mark-and-sweep concurrent garbage collector_.\n* Goal: maintain smallest heap size, with stop-the-world latency < 100microseconds per run.\n* The GC can take up to 25% of your CPU capacity.\n* Go's algorithm is called a **pacing algorithm**.\n\n## 2.4 - Constants\n* Constants only exist at compile time.\n* Constants can be \"of a kind\" or \"of a type\".\n* Literal values are of a kind, which are implicitly promoted and converted by the compiler. Once they're a type, all normal type rules apply.\n* The main thing is that Go has \"kind promotion\", which allows for movement between data types for constants.\n* Constants of a kind have 256-bit precision, making them the most high-precision thing in Go.\n* The `iota` keyword manages atomically, monotonically increasing unique IDs.\n\n\n"
    }
  ]
}