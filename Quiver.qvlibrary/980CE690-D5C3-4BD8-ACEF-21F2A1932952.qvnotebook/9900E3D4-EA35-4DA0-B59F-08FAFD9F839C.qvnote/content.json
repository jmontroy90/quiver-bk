{
  "title": "Slices",
  "cells": [
    {
      "type": "markdown",
      "data": "Slices are backed by arrays, so we start there.\n\n## Arrays\nArrays specify length and element type. `[5]int` is a different type than `[6]int`. They're indexed from zero. The zero value of an array is a ready-to-use array whose elements are themselves zeroed.\n\nArrays are simply sequential memory. They're values -- no pointers involved unless you bring them. \"One way to think about arrays is as a sort of struct but with indexed rather than named fields: a fixed-size composite value.\"\n\nTwo forms of creating array literals, both with resulting types of `[2]string`. The `...` tells the compiler to count elements.\n\n```\nb := [2]string{\"Penn\", \"Teller\"}\nb := [...]string{\"Penn\", \"Teller\"}\n```\n\n## Slices\n\n[Basic Usage](https://play.golang.org/p/xE260rNJ4N4)\n\nSlices have types like `[]string`, with no fixed length. Instead they rely on `make`, like: `func make([]T, len, cap) []T`. They're pointer-based e.g. reference types, and are backed by arrays.\n\nTheir zero-value is nil, since slices are reference types. A slice created by `var` instead of `make` will be a nil that can ACT like a zero-length slice (e.g. can append), whereas a `make` of length zero allocates memory. Note serialization issues though - a nil serializes to a JSON null, but a zero-length initialized slice to `[]`. Also note that a nil slice has length and capacity of zero.\n\nInternally, they're a descriptor of an array segment, where they have a pointer to an element plus a length of segment and total capacity. This means if you inspect a slice in memory, you can take the address of a slice + some word length to get to the memory storing the length and cap.\n\n![IMAGE](quiver-image-url/5443E4863FE968255B7E81F55E28D40E.jpg =517x193)\n\nA slice's length can't exceed its capacity, so copying and growing slices are common operations. The built-ins `copy` and `append` do this, where `append` just grows the slice as needed by copying to a slice backed by a bigger backing array (based on your input data).\n\n## Sharing\n\n[Basic Sharing](https://play.golang.org/p/ebvnbTWksmZ)\n\n## Iterating\n\nThe two-tuple syntax of the `range` keyword uses value semantics over a slice. This means that your slice elements are copied into the left-hand side of a `range` statement. The pointer semantics form (single index value on left-hand side) still allocates a var for the index, but doesn't make a copy of slice.\n\nRange semantics are hard and specific.\n\n[See more](https://play.golang.org/p/S09sex4QjXs)\n[And even more](https://play.golang.org/p/ejhwpTGLwEp)\n\n## Append\n\nThe `append` built-in does a lot.\n\nIt doubles capacity per reallocation for the first few thousand elements, then grows at roughly a rate of 1.25 per realloc.\n\nA new slice value is NOT created per `append` call -- the passed-in slice is copied onto the stack, and the original memory is re-used for the returned slice. Nice!\n\n## Gotchas\n\n* Returned slices that refer to some tiny subarray of their backing storage array will prevent the GC from collecting any of that backing array. This is a memory leak.\n* Slices that share a backing array can mess with each other. Remember a slice is just a descriptor with a pointer, but the backing storage can be mutably modified underneath multiple descriptors."
    }
  ]
}