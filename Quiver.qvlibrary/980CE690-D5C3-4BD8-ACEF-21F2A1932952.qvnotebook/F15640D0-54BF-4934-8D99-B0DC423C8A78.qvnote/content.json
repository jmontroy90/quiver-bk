{
  "title": "Maps",
  "cells": [
    {
      "type": "markdown",
      "data": "## Review Questions\n1) Initialization syntax? Zero values?\n2) Built-ins? Semantics of those?\n3) Implementation basics? Properties of hashing functions, hash maps?\n4) `runtime` types of interest?\n5) Growth process and heuristics?\n6) Concurrency?\n7) Sharing semantics?\n\n## Intro\nA map is an array where **you** specify the indexes -- guarantees on contiguous memory, constant-time access, and collision-free adds go away, but you have the freedom to store and retrieve things how you want, in a way you can later reproduce.\n\n## Articles\n* [Go Maps in Action](https://blog.golang.org/go-maps-in-action)\n* [How the Go runtime implements maps efficiently (without generics)](https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics)\n\n## Usage\n\n* [Basic Usage](https://play.golang.org/p/y1qE1-G-Vej)\n* [Sharing](https://play.golang.org/p/uXKF3XviCZa)\n\nYou `make` maps. They're composite types types, and pseudo-reference types. **A normal `var` initialization will lead to a `nil` map, which panics on assignment.**\n\nMaps are case-sensitive for strings, and map literals can't have duplicate keys on initialization. **Duplicate keys added post-initialization are totally fine.**\n\nUse boolean guards to access safely: `value, ok := m[key]`\n\nUse `len` for size. There is no `cap`. Use `delete` (e.g. `func delete(m map[Type]Type1, key Type)`) to remove elements. **Slight gotcha**: you can `delete` from a `nil` map, an empty map, and on a key that doesn't exist. They're all silent no-ops.\n\nYou can key-value iterate over a map using `range`. **The order is nondeterministic.** If you need stable iteration over a map, build a slice and use that.\n\n**Never share maps with pointers.** Calls to maps are rewritten at compile time to calls to the `runtime` library, which make use of a backing implementation. Your actual map is thus just rewritten to be a pointer to a `runtime.hmap` (more below). So if you assign an existing map to a new variable, both variables will reference (and be mutated by) the same backing map.\n\n**Maps use zero values for missing keys**. The Go Blog gives some contrived examples for this -- detecting cycles in a linked list, for example, can be performed without the hefty, hefty burden of checking if a key in a `visited` map both exists and has a value of `true`. I kind of hate this -- here it's fine, the `visited` pattern is just an initialization in disguise. Equally the \"map of likes per person\" example -- it's allocation and growth. **If you're checking carelessly for values, this can hurt you. Always check your guards.**\n\n**Keys must be comparable -- this includes structs!** Use structs as keys for more complex permutations of data points; you don't need a map of maps, you just need a struct key. \n\n> side bar -- what about nil types in structs? be careful?\n\nThe default sizing and byte allocation of a map made with `make` and no size argument depends on the implementation, but typically around 48 bytes on a 64-bit architecture ([link here](https://stackoverflow.com/questions/46278003/how-much-memory-do-golang-maps-reserve)).\n\n## Implementation\n\nGo Maps are hash maps. They offer `O(1)` best-case, and `O(n)` worst-case. The constant size and frequency of cases depends on the hashing function. A hashing function derives a value associated with a key, usually an int, always of fized size.\n\nHash functions must be **stable** and **well distributed** -- they must always be deterministically one-to-one, and in order to avoid collisions or overstuffed buckets, two similar input keys should hash \"wildly differently\".\n\nA hash map in Go is an array of buckets -- by default, eight buckets that can store eight entries each. To insert, we hash our key, mask off the lower three bits to determine the bucket, scan through that bucket till we find an open entry, then stick it there. Finding is the same -- hash, lower 3 bits for correct bucket, linear search through bucket.\n\nThere are secretly two data structures per bucket:\n![IMAGE](quiver-image-url/ECCD894DA85C458449E007830C923362.jpg =640x417)\n\nThe array of HOB (higher-order bit) hashes are used to distinguish entries, and the keys / values are packed appropriately for iteration access. The packing helps on byte alignment to save the bytes.\n\nProperties of a hash map:\n1) Hash function\n2) Comparable keys\n3) key size\n4) value size (for array stepping!)\n\nDave Cheney's article looks at hash map implementations in C++ and Java. Java suffers from boxing of primitives in order to use of keys, and linked list traversal per bucket (unbox / deref city!!). C++ is cool, but all Maps are different types.\n\nGo map commands are implemented in the runtime library of Go, and the compiler rewrites the above commands to these runtime library calls:\n```\nv := m[\"key\"]     → runtime.mapaccess1(m, ”key\", &v)\nv, ok := m[\"key\"] → runtime.mapaccess2(m, ”key”, &v, &ok)\nm[\"key\"] = 9001   → runtime.mapinsert(m, ”key\", 9001)\ndelete(m, \"key\")  → runtime.mapdelete(m, “key”)\n```\n> sidebar -- this is what channels do too\n\nThese runtime calls do NOT use `interface{}` -- they use similar structs behind the scenes to what `interface{}` itself uses. For example:\n```\nfunc mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer\n```\n`maptype` contains metadata about the map itself -- there's one `maptype` **value** for each map in your uncompiled code. It has fields of type `_type`, which is a struct that contains details on size, alignment, and equality via `typeAlg`. This `typeAlg` does hashing and comparison, so your map access function looks (mostly) like this:\n```\nfunc mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {\n\tif h == nil || h.count == 0 {\n\t\treturn unsafe.Pointer(&zeroVal[0])\n\t}\n\talg := t.key.alg\n\thash := alg.hash(key, uintptr(h.hash0))\n\tm := bucketMask(h.B)\n\tb := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n\t// ...\n}\n```\n\nNote -- the one `maptype` _value_ per unique map is the big edge over C++ -- C++ does one _implementation_ per unique map, ew.\n\nAll this to say -- maps are NOT reference types:\n> A map value is a pointer to a runtime.hmap structure.\n\nThis means you should NEVER pass some function a pointer to a map, e.g. `*map[string]int` -- they're already pointers! Slices are reference types, which is why you don't exactly pass those as pointers either. They're shared automagically.\n\n### Growth\nMaps add \"overflow buckets\" as needed when a given bucket fills (> 8 values). These are attached to the original buckets.\n\nGo uses a couple of heuristics to determine when to grow a map. These are:\n```\n**% overflow**: Percentage of buckets which have an overflow bucket\n**bytes/entry**: Number of overhead bytes used per key/value pair\n**hitprobe**: Number of entries that need to be checked when looking up a key\n**missprobe**: Number of entries that need to be checked when looking up an absent key\n```\n\nThe current values are listed in comments in `map.go` in the `runtime` library.\n\n\"Growing a map\" involves allocating a new bucket array with twice the number of buckets. This is done by \"evacuating\" the original buckets **at access time** to new buckets. There's no correspondance between old bucket keys and new ones -- old buckets might be split across multiple new buckets. This delicate process means that Go does a lot of work to iterate across both the old and new bucket arrays until the old array is _completely empty_.\n\n## Concurrency\n\n**Maps are not safe for concurrency!** Use a `sync.RWMutex()` for threadsafe access, where `RLock()` is for reading and `Lock()` is for writing. This choice was made because most map usages don't involve concurrent access. Note - you don't need a mutex if everyone is just reading. Use the race detector if you're unsure.\n\n**Maps are not addressable**. They contain a significant amount of internal state (especially for `range` operations on them), and must occassionally move things around behind the scenes to keep their `O(1)` guarantees.\n\n> side bar -- their example has the mutex in a struct along with the map. Any problems using a separate mutex var?\n\n## Gotchas\n\n## Performance"
    }
  ]
}