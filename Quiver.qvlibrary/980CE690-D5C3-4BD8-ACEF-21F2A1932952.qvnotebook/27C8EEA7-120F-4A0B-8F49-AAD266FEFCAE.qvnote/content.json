{
  "title": "Modules",
  "cells": [
    {
      "type": "markdown",
      "data": "### [Using Go Modules - Part 1](https://blog.golang.org/using-go-modules)\nModules define a module path for a set of packages. You need the full `github.com/.../...` path to specify the module path + a semantic version. Starting in 1.13, modules are standard both outside and inside your `GOPATH`.\n\nImporting a package contained within a module will import the whole module. \"The (sub)package would automatically be recognized as part of the example.com/hello module, with import path example.com/hello/world\"\n\nWhen you `init` modules, you specify the module name as that `github.com/...` full module path for importing.\n\nWhen you add a dependency, a few things worth noting:\n1) Transitive dependencies are included if needed, probably some pruning is done.\n2) Some dependencies may have [pseudo-versions](https://golang.org/cmd/go/#hdr-Pseudo_versions). Pseudo-versions are generated from timestamp and commit if the tagged releases on GitHub don't match Go's SemVer expectations on format.\n    * This changed in Go 1.13.\n3) The **latest** version is automatically found and imported when you run `go get`. \"`Latest` is defined as the latest tagged stable (non-prerelease) version, or else the latest tagged prerelease version, or else the latest untagged version (e.g. commit)\"\n4) `go.sum` contains cryptographic hashes of of package contents, to ensure that contents for the same versions over time don't change underneath you.\n\nBoth `go.mod` and `go.sum` should be checked into source control. \n\n* `go list -m all` will give you all your dependencies. Only works in 1.12 with proper SemVer-formatted tags.\n* `go list -m -versions <package-name>` will get available versions you can upgrade to. Only works in 1.12 with proper SemVer-formatted tags.\n* `go get` with an `@` for version will select a particular commit OR a particular branch!\n    * `go get gecgithub01.walmart.com/wce/multiclusterapp-controller@STRCONTAIN-3714-endpoint-controller-dst-api` was totally successful.\n    * This can be package by package, like all non-`mod` commands.\n* `go mod tidy` will clean up unused dependencies.\n* `go mod graph` will show you a pretty unhelpful dependency tree via text.\n* `go mod why -m <module>` will show you middlingly useful information about what brings in each dependency.\n\nAlso, [semantic import versioning](https://research.swtch.com/vgo-import) is recommended for major version changes -- so `me.com/mypackage` goes to `me.com/mypackage/v2` when you move to v2. This is a separate package path!\n\n### [Publishing Go Modules](https://blog.golang.org/publishing-go-modules)\nAll modules use a semantic version of `vMAJOR.MINOR.PATCH`. Pre-release versions like `v2.2.2-beta.2` are appended. `go get` and imports will prefer normal releases over pre-releases. Pseudo-versions based on commits are also available when an explicitly tagged version hasn't been released yet.\n\n`v0` can have breaking changes between MINOR versions, but once you hit `v1`, you're promising stability. Every release should have the following commands run at a minimum (for an example `v1.0.0` release):\n```\n$ go mod tidy\n$ go test ./...\n$ git add .\n$ git commit -m \"hello: changes for v1.0.0\"\n$ git tag v1.0.0\n$ git push origin v1.0.0\n```\n\n### [Go 1.13](https://golang.org/doc/go1.13#modules)\nVariables like `GOPROXY` and `GOSUMDB` allow you to specify different locations to pull modules and checksums from. This can be useful in partitioned / sandboxed network environments.\n\n`go get` and \"module-aware\" mode is something I don't totally follow.\n\nVersions are now validated for modules. The `+incompatible` flag shows when something has not followed semantic import versioning. Also we want to check if the repo has an explicit `go.mod` file, and validate the timestamps and SHAs for pseudo-versions.\n"
    }
  ]
}