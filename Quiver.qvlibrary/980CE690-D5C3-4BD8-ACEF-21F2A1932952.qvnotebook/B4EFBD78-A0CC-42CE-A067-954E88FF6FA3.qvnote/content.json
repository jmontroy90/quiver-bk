{
  "title": "Interfaces",
  "cells": [
    {
      "type": "markdown",
      "data": "An interface is an abstract type that defines behavior -- this behavior helps unrelated entities communicate with one another. More technically, they define a method set _with no receiver_.\n\nSince interfaces are duck-typed at compile time, Go allows you to define new data that conforms to an interface at any time -- no subclassing or explicit `implements`. Conversely, you can abstract an interface out of concrete data types, or even narrow down a wide interface.\n\nInterfaces in Go are NOT constricting -- much like working with some third-party API, you have to read the docs to understand exactly how to fulfill the interface's contract.\n\nRemember how Java people might go about interfaces -- they define them just to implement them once or MAYBE twice. The interfaces broaden out and implemented explicitly by a couple classes, leading to bulky, inelegant things. Interfaces in Go are different -- keep them small, don't export them unless you have to, tell your users to make an interface if they need to mock. See implementation below for why this is possible in Go -- a C++ static dispatch table requires an interface to know about its implementers. Go does this on the fly during interface value assignment.\n\nIf you want to study best practices, go with the `io` standard library.\n\nInterfaces are particularly good for composition because of embedding -- this is like a **big decorator**. It's also great for **breaking dependencies** -- instead of importing an explicit package and struct, you can just create an interface out of the original struct, which narrows the contract and removes the dependency.\n\nInterface values can be converted to concrete types with simple casts -- this can allow you to create some new type with things you need (e.g. `type Sequence []int`), then convert that underlying concrete type to some other conforming concrete type (e.g. `sort.IntSlice` here). This allows you to use other interfaces really easily, and is another form of DRY, maintainable code:\n```\ntype Sequence []int\n\n// Method for printing - sorts the elements before printing\nfunc (s Sequence) String() string {\n    s = s.Copy()\n    sort.IntSlice(s).Sort()\n    return fmt.Sprint([]int(s))\n}\n```\n\nType switches are available on interfaces. Asserting a concrete type on an interface is a definite smell, but **asserting a behavior on an interface** (e.g. interface on interface) is REALLY nice. For example, asserting whether an error (of the Error interface) is `Temporary` lets you access really useful codepaths very generically. It's still a specification that _could_ evolve as your interface landscape evolves, but managing behaviors is much better than managing types.\n\nContract **type switches with type assertions** -- one is the `switch t.(type)` and the other is `str, ok := value.(string)`.\n\nThis type assertion also really helps type evolution -- implement a new method on your type, create a new interface out of that (or compose it?), and type assert on the interface wherever you need to use it!\n\nAnything can implement an interface:\n```\n// Simpler counter server.\ntype Counter int\n\nfunc (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n    *ctr++\n    fmt.Fprintf(w, \"counter = %d\\n\", *ctr)\n}\n```\n\nOr think about `HandlerFunc`, which has methods for adapting raw functions to an HTTP handler!\n\n[Examples of asserting usefully to help evolve / cover lots of different data](https://play.golang.org/p/Fqy_pvttSNi)\n[Some nil checking with sharing](https://play.golang.org/p/vp_VccSVlhQ)\n\n## Implementation\n\nInterfaces are structs that look like this:\n![IMAGE](quiver-image-url/95A2F3F75CDC029D0D6368CF66D1B265.jpg =486x238)\n\nThe `itable` is the magic -- so when you pass a struct into a function that takes an interface, this struct has to be generated on the backend. Your data ends up **copied** onto the heap with a pointer to it, and the `itable` allows for method lookup as pertains to the given interface. This is like a C++ virtual function table.\n\nType assertions on interfaces use the `itable`'s `type` field, and method dispatches will generate C code like `s.tab->fun[0](s.data)`, where `fun[0]` is an entry in the functions list that gets the raw pointer's data (either the pointer or a raw value, depending on size) as its first argument.\n\nTo compute an `itable`, each struct and each interface can have a type descriptor that has a list of methods. When the runtime gets a struct for an interface, the `itable` can be computed by looking up a struct's methods in the interface's method list. This `itable` will be cached, and further optimizations come from precomputing `itable` at initialization rather than at a method call (dynamic dispatch languages like Smalltalk and Python look up the methods each and every call).\n\nThe above is the static case -- dynamic conversions involve a merging of method lists between the interface types, using method name and type hash. If the old type doesn't contain a method the new type needs, the runtime interface conversion fails.\n\nNote, usually the data is copied on heap, but if it fits in a single word for the architecture, it'll go in the interface struct's data word as a value and all calls on method receivers will be adjusted behind the scenes appropriately.\n\n## Pointer vs Value Receivers\n\n![IMAGE](quiver-image-url/32FD4415755278E533FE5BCB58862359.jpg =964x458)\n\nBasically, if you implement an interface on a type with pointer semantics, don't wrap a value of that type in the interface. Not everything is addressable, firstly. Secondly, if you wrap a value, you create a new value to be stored. Then any future modifications on that value using pointer semantics (NOT the methods) don't reach the interface value, and vice versa. You'll have a serious data integrity issue.\n\nThis also applies slightly for passing interface values to functions -- the difference is that you **can't** pass the wrong type (wrong receiver type in implementation) to a function. That's just type checks.\n\n## Gotchas\n\nWhen you convert something to an interface value, that value is now a struct with type descriptor, pointer to raw value, etc. This is why an interface value of value `nil` will not be the same as an actual `nil` -- behind the scenes, it's all a big struct.\n\nRelated to this is the idea of **dynamic types** and **dynamic values**. A static type is what's assigned at initialization. A dynamic type for interfaces reference the underlying type, e.g. static type == `myInterfacer`, dynamic type == `structThatImplements`. \n\nAll this to say: be careful if you're returning interface values and checking for nil! And when I say be careful, I mean DON'T do it. Its nil semantics are surprising and you don't need to return an interface regardless.\n"
    }
  ]
}