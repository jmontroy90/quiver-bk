{
  "title": "The Kernel Boot Process",
  "cells": [
    {
      "type": "markdown",
      "data": "[Link to article](http://duartes.org/gustavo/blog/post/kernel-boot-process/)\n\n_Note: I didn't want to be here. The article just seemed too good._"
    },
    {
      "type": "markdown",
      "data": "After the boot loader (let's say GRUB) has gone through its instructions from a designated boot sector, and then loaded the kernel into main memory via \"unreal mode\" (just switching between real mode and protected mode in order to get the kernel image into main memory). This is what the kernel looks like in main memory:\n\n![IMAGE](quiver-image-url/C210DA1E2FB984CC105EB9480E041D6E.jpg =654x496)\n\nThis is in two pieces to reflect the real mode / protected mode memory limits - the action starts in the real-mode kernel header. There's human-readable strings like version numbers and (I think) user-specified boot args (written by the boot loader). This is also where the kernel entry point lives.\n\nThere's a bit of legacy boot sector code and the real-mode kernel header code that constitute the first 512K of the kernel entry point. The first **instruction** executed jumps to an assembly routine called `start_of_setup()`, which does a few things:\n* Sets up a stack\n* Zeroes out `bss` for the real mode kernel (static variables)\n* Jumps to actual C code of `arch/x86/boot/main.c`\n\nThe next call is `go_to_protected_mode()` - nicely consistent function calls. Before this is done, the `GDT` and `IVT` (interrupt vector table - just interrupts and exceptions) tables need to by referenced by placing memory locations in the _idtr_ and _gdtr_ registers, so `setup_idt()` and `setup_gdt()` are called.\n\nNow that setup is done, `protected_mode_jump()` finally brings us into protected mode. We call the 32-bit kernel entry point and also `decompress_kernel()` and overwrite the original compressed one above.\n\n`startup_32()` will do the following:\n1) Clear the `bss` segment for 32-bit real-mode kernel\n2) Set up final GDT pages for address translation\n3) Build page tables to enable paging\n4) Create a final interrupt descriptor table\n5) build a stack\n6) jump to `start_kernel()`\n\nFrom here, we're deep in kernel land - \"scheduler, memory zones, time keeping, etc\". A `cpu_idle()` thread will then be scheduled and run until CPU time is needed by another process.\n\nAll other CPUs need to be brought through similar paths - remember, this has all been run on one bootstrap processor, and now application processors need to be brought through real mode and protected mode.\n\nLastly - `kernel_init()` passes `init_post()` to be scheduled and executed, which tries to start user-mode processes like `/sbin/init`, `/etc/init`, `/bin/init`, and `/bin/sh` (in that order). `init` (usually the winner) will then go through user-mode startup configs and applications, and hooray we go."
    }
  ]
}