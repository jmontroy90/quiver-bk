{
  "title": "Chapter 14 - Component Coupling",
  "cells": [
    {
      "type": "markdown",
      "data": "More principles on coupling! Yay acronyms!\n\n### The Acyclic Dependencies Principle\n\n> Allow no cycles in the component dependency graph.\n\nSmell: \"You may have wondered why you have to include so many different libraries, and so much of everybody elseâ€™s stuff, just to run a simple unit test of one of your classes.\"\n\nThe \"morning-after\" syndrome is having to manage merge conflicts every time your time co-iterates. To avoid this, partition your codebase into components, where the component dependency graph forms a DAG. Cycles increase the complexity of releasing and merging. If you have a DAG of components, you can simply follow that DAG from the bottom up to release your code. \"Get the smallest thing working, and then get the things that use that working, and so on\".\n\nHere's an example app broken down into components. Notice there are no cycles.\n![IMAGE](quiver-image-url/6572CA6D290F8531C590608049E527B0.jpg =499x284)\n\nSay you introduce a cycle by having Entities depend on Authorizer, as such:\n![IMAGE](quiver-image-url/CF8BAF115B5E5A37B7120286E534DB0F.jpg =500x284)\n\nBreak it up! We could do this via DIP as such:\n\n![IMAGE](quiver-image-url/015B9A27F32A774B5CD4712ACDDE6DAA.jpg =547x284)\nThis is an interface owned by the Entities, saying \"this is what I expect from any `Permissions` class\". Then `Authorizer` can implement that interface!\n\nYou could also create a whole new `Permissions` component -- moving around and adding components is \"jitter\", and should be managed over time to prevent cycles.\n\n### Top-Down Design\nIn short - we can't design our component dependency graph first. Functional abstractions can help early on, but the components that embed those functions aren't going to be well-understood for awhile. If you try to understand SRP, CCP, common closure -- you're gonna mess it up.\n\n(I think this thought has parallels with suffering-oriented programming too, and a good follow-up question is exactly how high-level you should get with your functions / related abstractions.)\n\n### The Stable Dependencies Principle\n> Depend in the direction of stability.\n\n### The Stable Abstractions Principle\n> A component should be as abstract as it is stable.\n\n\"...if a component is to be stable, it should consist of interfaces and abstract classes so that it can be extended. Stable components that are extensible are flexible and do not overly constrain the architecture.\"\n\nThis says: \"Dependencies run in the direction of abstraction\", which is the above two principles combined to amount to the DIP. OCP also allows us to extend functionality while leaving high-level stuff abstract and stable.\n\nWe can graph the stability vs. level of abstraction of a component, and bucket components into zones as such:\n![IMAGE](quiver-image-url/FF3A34821C3BCD5F5C9CB76E4D44A9CD.jpg =314x284)\n\n"
    }
  ]
}