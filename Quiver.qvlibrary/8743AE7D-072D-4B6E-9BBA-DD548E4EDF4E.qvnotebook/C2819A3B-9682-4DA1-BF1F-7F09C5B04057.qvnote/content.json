{
  "title": "Chapter 15 - What Is Architecture?",
  "cells": [
    {
      "type": "markdown",
      "data": "The strategy behind software architecture is \"to leave as many options open as possible, for as long as possible.\"\n\nMore specifically:\n>The primary purpose of architecture is to support the life cycle of the system. Good architecture makes the system easy to understand, easy to develop, easy to maintain, and easy to deploy. The ultimate goal is to minimize the lifetime cost of the system and to maximize programmer productivity.\n\nAnd when you ignore architecture:\n>However, the architecture of a system has very little bearing on whether that system works. There are many systems out there, with terrible architectures, that work just fine. Their troubles do not lie in their operation; rather, they occur in their deployment, maintenance, and ongoing development.\n\nA system should be easy to **develop**. Small teams can move quickly with a custom architecture and siloed knowledge -- big frameworks for modularity would provide unnecessary barriers in the beginning. But! Those knowledge silos will prove to be huge hurdles as the team / product grows. Either you end up with a big, slow, institutionalized mess, OR you end up with X different systems for X different teams.\n\nA system should be easy to **deploy**. For example, microservices are great for modularity and decoupling, but they can be pretty terrible to deploy in terms of dependency management.\n\n**Operations** should be obvious in a good system. Let's make our use cases first-class citizens in our architecture, such that it's obvious why and how we can improve our architecture.\n\nOur system should be easy to **maintain**! \n> By separating the system into components, and isolating those components through stable interfaces, it is possible to illuminate the pathways for future features and greatly reduce the risk of inadvertent breakage.\n\n### Policy vs Details\nWe separate our architecture into **policy** and **detail**. Policies encode business logic and drive value. Details are most everything else that programmers like to sweat about.\n\n> The goal of the architect is to create a shape for the system that recognizes policy as the most essential element of the system while making the details irrelevant to that policy. This allows decisions about those details to be delayed and deferred.\n\nHere are some details he lists. This is a good list.\n\n> It is not necessary to choose a database system in the early days of development, because the high-level policy should not care which kind of database will be used. Indeed, if the architect is careful, the high-level policy will not care if the database is relational, distributed, hierarchical, or just plain flat files.\n\n> It is not necessary to choose a web server early in development, because the high-level policy should not know that it is being delivered over the web. If the high-level policy is unaware of HTML, AJAX, JSP, JSF, or any of the rest of the alphabet soup of web development, then you don’t need to decide which web system to use until much later in the project. Indeed, you don’t even have to decide if the system will be delivered over the web.\n\n> It is not necessary to adopt REST early in development, because the high-level policy should be agnostic about the interface to the outside world. Nor is it necessary to adopt a micro-services framework, or a SOA framework. Again, the high-level policy should not care about these things.\n\n> It is not necessary to adopt a dependency injection framework early in development, because the high-level policy should not care how dependencies are resolved.\n\n> I think you get the point. If you can develop the high-level policy without committing to the details that surround it, you can delay and defer decisions about those details for a long time. And the longer you wait to make those decisions, the more information you have with which to make them properly.\n\nIn short - \"A good architect maximizes the number of decisions not made.\"\n\nThis chapter is very quotable.\n\n"
    }
  ]
}