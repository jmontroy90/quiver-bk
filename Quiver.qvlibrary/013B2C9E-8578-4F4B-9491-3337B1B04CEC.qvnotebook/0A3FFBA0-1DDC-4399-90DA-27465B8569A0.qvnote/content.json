{
  "title": "API Server",
  "cells": [
    {
      "type": "markdown",
      "data": "A single instance is a **resource**, corresponding to one **resource type** (e.g. `pod`, `desiredstate`). They're grouped by `Group-Version-Kind` ordering, where a particular group of resources all evolves together (e.g. `batch/v2alpha/...`)\n\nThe Kubernetes API is a massive RESTful API. All normal verbs (POST, PUT, PATCH, DELETE, GET) are supported for resource types. These resource types can be _cluster-scoped_ or _namespace-scoped_.\n\nRemember: `/api/v1/...` is legacy core.\n\nAll resource types offer **consistent lists** and **watches**, allowing clients to watch a resource past some specified `resourceVersion`. etcd3 doesn't keep lists of changes for long, so _bookmarks_ are an alpha feature providing info on what events have already been sent. If a `resourceVersion` doesn't exist, k8s returns a `410 Gone` which should be handled.\n\nThe API offers **breaking responses into smaller chunks**, with a `limit` parameter and a `continue` token. For example, you'd `limit` to 500 pods per request, and the response would also include a `continue` token if there are more results to return. Your next request should include that token (expires after 5min by default, yielding a 410) to get the next set of results. The `continue` token guarantees you'll get one consistent list of a resource type, all within one `resourceVersion`.\n\nMany **data formats** are available. By default, the API works with JSON. Using the `Accept` header for GET requests allows you to get protobuf, and `Content-Type` for POST, PUT, etc. You can specify one type for requests (`Content-Type`), and one different one for responses (`Accept`). You can also specify mutliple in `Accept` because some resources may not have protobuf.\n\n**Dry run**s are valuable for the k8s API - they go through every stage except the final persistence stage in etcd:\n> Admission controllers are run to check that the request is valid, mutating controllers mutate the request, merge is performed on PATCH, fields are defaulted, and schema validation occurs.\nIf admission / mutating webhooks have side effects, either a dry run must fail automatically for those hooks, OR the hook must be aware of the dry run flag, as to avoid performing those side effects.\n\n**Server-Side Apply** brings a concept of _field managers_ to conflict resolution in updates. A given field manager could be \"kubectl\" or \"kubeadm\". It'll eventually be the way all `apply` calls are done. It's an alpha feature that requires configuration. It also comes with merge strategies based on field managers, like \"overwrite and become field manager\", \"don't overwrite, become shared manager\".\n\nServer-Side Apply guarantess that clients don't go stale.\n"
    }
  ]
}