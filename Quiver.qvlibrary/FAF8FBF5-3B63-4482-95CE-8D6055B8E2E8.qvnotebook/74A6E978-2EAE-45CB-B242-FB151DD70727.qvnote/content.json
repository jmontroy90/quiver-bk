{
  "title": "Chapter 18 - Software Engineering in SRE",
  "cells": [
    {
      "type": "markdown",
      "data": "This chapter has a big case study on capacity planning, and going from labor-intensive data collection and static capacity planning to **Intent-Based Capacity Planning**:\n\n> 1) \"I want 50 cores in clusters X, Y, and Z for service Foo.\"\n> This is an explicit resource request. But…why do we need this many resources specifically in these particular clusters?\n>\n> 2) \"I want a 50-core footprint in any 3 clusters in geographic region YYY for service Foo.\"\n> This request introduces more degrees of freedom and is potentially easier to fulfill, although it doesn’t explain the reasoning behind its requirements. But…why do we need this quantity of resources, and why 3 footprints?\n>\n> 3) \"I want to meet service Foo’s demand in each geographic region, and have N + 2 redundancy.\"\n> Suddenly greater flexibility is introduced and we can understand at a more \"human\" level what happens if service Foo does not receive these resources. But…why do we need N + 2 for service Foo?\n> \n> 4) \"I want to run service Foo at 5 nines of reliability.\"\n> This is a more abstract requirement, and the ramification if the requirement isn’t met becomes clear: reliability will suffer. And we have even greater flexibility here: perhaps running at N + 2 is not actually sufficient or optimal for this service, and some other deployment plan would be more suitable.\n> \n> So what level of intent should be used by intent-driven capacity planning? Ideally, all levels of intent should be supported together, with services benefiting the more they shift to specifying intent versus implementation. In Google’s experience, services tend to achieve the best wins as they cross to step 3: good degrees of flexibility are available, and the ramifications of this request are in higher-level and understandable terms. Particularly sophisticated services may aim for step 4.\n\nTo do this kind of sophisticated intent-based capacity planning, we need to understand a service's dependencies (some backend database? what latency between them?), its performance metrics (how much CPU is required to serve N requests/sec?), and its prioritization (what other services might be able to steal its resources?).\n\n**Auxon** does this to collect these constraints, quantize them, and solve a giant bin-packing problem (\"giant mixed-integer or linear program\") for resource allocation. It takes a lot of input config, performance data, forecasting, etc., and loads it all. It's basically a giant constrained optimization problem.\n\nIt's an example of SRE software done right:\n* The team building it knew the domain well, and was also on-call for it in production, so there was a lot of good dog-fooding. No \"chuck over the fence\" model here.\n* \"When deploying approximation to help speed development, it’s important to undertake the work in a way that allows the team to make future enhancements and revisit approximation. In the case of the Stupid Solver, the entire solver interface was abstracted away within Auxon such that the solver internals could be swapped out at a later date. Eventually, as we built confidence in a unified linear programming model, it was a simple operation to switch out the Stupid Solver for something, well, smarter.\"\n    * This is the smart take on \"suffering-oriented programming\" -- it's not an excuse to not set up your program intelligently and maintainably.\n* \"Building software with fuzzy requirements can be a frustrating challenge, but some degree of uncertainty need not be a showstopper. Use this fuzziness as an incentive to ensure that the software is designed to be both general and modular.\"\n* \"If there’s one theme to draw from our Auxon case study, it’s that the old motto of \"launch and iterate\" is particularly relevant in SRE software development projects. Don’t wait for the perfect design; rather, keep the overall vision in mind while moving ahead with design and development. When you encounter areas of uncertainty, design the software to be flexible enough so that if process or strategy changes at a higher level, you don’t incur a huge rework cost. But at the same time, stay grounded by making sure that general solutions have a real-world–specific implementation that demonstrates the utility of the design.\"\n\nSome lessons:\n1) **Raising Awareness and Driving Adoption**: an email blast is not enough. You need to get out there, showing how your tools solve real problems.\n2) **Set expectations**: MVPs and limited feature scopes are okay. Provide roadmaps and give an idea of immediate vs. long-term benefits.\n3) **Identify appropriate customers**: some teams might have some form of your product; maybe choose teams that don't have anything, and then document their savings and benefits.\n4) **Customer service**: don't be afraid to be hands-on, assuring the teams they're not being automated away, pointing to early adopters, showing what work they're now free to do.\n5) **Designing at the right level**: -- \"come as you are\", e.g. with whatever data, \"agnosticism\", designing your product to flexible and modular\n\n**Good projects** for SRE software development: cross-cutting application, interested SREs with domain expertise, a technical user base for strong feedback loops.\n\n**Bad projects** for SRE software development: too specific, touches too many moving pieces at once, too general and abstract.\n\nSREs are technical generalists, breadth-first types, who should be paired with domain experts, product managers, and so on.\n\n> However, in any of these scenarios—and this is a point worth stressing—it’s essential that the SREs involved in any development effort continue working as SREs instead of becoming full-time developers embedded in the SRE organization. Immersion in the world of production gives SREs performing development work an invaluable perspective, as they are both the creator and the customer for any product.\n\nHow to foster software development culture in SRE orgs:\n\n> First, recognize that this goal is as much an organizational change as it is a technical challenge. SREs are used to working closely with their teammates, quickly analyzing and reacting to problems. Therefore, you’re working against the natural instinct of an SRE to quickly write some code to meet their immediate needs. If your SRE team is small, this approach may not be problematic. However, as your organization grows, this ad hoc approach won’t scale, instead resulting in largely functional, yet narrow or single-purpose, software solutions that can’t be shared, which inevitably lead to duplicated efforts and wasted time.\n\nSREs are skeptical and may lack PM-adjacent skills. If you get from \"why\" to \"how\", you're doing well.\n\nBenefits of software:\n* Consistent and supported software solutions speed ramp-up for new SREs.\n* Reducing the number of ways to perform the same task allows the entire department to benefit from the skills any single team has developed, thus making knowledge and effort portable across teams.\n* Ask yourself: if this product were created by a separate dev team, would you onboard the product?\n\nRemember, MVPs are crucial to showing value and establishing trust and interest. Don't relax your standards though.\n\n\n"
    }
  ]
}