{
  "title": "Design Principles and Design Patterns",
  "cells": [
    {
      "type": "markdown",
      "data": "[Link to paper](https://fi.ort.edu.uy/innovaportal/file/2032/1/design_principles.pdf)\n\n### Symptoms of Rotting Design\n* _Rigidity_ — software is hard to change; changes radiate out to affect huge swaths of the codebase\n* _Fragility_ — software breaks unexpectedly with small changes\n* _Immobility_ — it's difficult to re-use identical-in-function software components in different parts of your code\n* _Viscosity_ — easy to do the wrong thing, hard to do the right thing!\n\nWe have to design to be impervious to changing requirements and dependency management! They have to be taken as axiomatic, and we should design with them in mind (much in the same way we design distributed, cloud-based systems to be fault-tolerant — since when are humans less faulty than machines?!).\n\n### Principles of Object Oriented Class Design\n\nTogether, these constitue most of `SOLID`, although S is missing. I think it's fairly trivial.\n\n#### The Open Closed Principle (OCP)\n\nIn short -  classes should be written such that they can be extended **without** modifying the original class. This is basic subtype polymorphism, coupled with using abstraction properly in parent classes. Good quote: \n> \"It is always better if changes do not propogate into existing code that already works. If you don’t have to change working code, you aren’t likely to break it.\"\n\n#### The Liskov Substitution Principle (LSP)\n\n> Derived classes should be substitutable for their base classes.\n\nHe gives the example of the Circle / Ellipse dilemma, where basically \"all circles are ellipses\", but if a client passes in a circle into a function that mutates things as ellipses (which is totally valid based on inheritence), things will go poorly! Of course, this is only a problem in a mutable world! Another argument for immutability.\n\n```\nvoid f(Ellipse& e) {\n  Point a(-1,0);\n  Point b(1,0);\n  e.SetFoci(a,b);\n  e.SetMajorAxis(3);\n  assert(e.GetFocusA() == a);\n  assert(e.GetFocusB() == b);\n  assert(e.GetMajorAxis() == 3);\n}\n```\n\nLSP is about making implicit contracts of a class explicit. There are certain preconditions and postconditions, and if you can recognize those, you're in business. A restatement:\n\n> Derived methods should expect no more and provide no less\n\n#### The Dependency Inversion Principle (DIP)\n\nAs much as possible, classe should depend on abstract interfaces rather than concrete implementations. This pairs with the OCP nicely, in the sense that if you do this well, you'll never have to modify parent classes due to some child class implementation. This is hard, but worth it.\n\n#### The Interface Segregation Principle (ISP)\n\nInstead of chunking together in one class all your interfaces corresponding to different clients / entry points, separate those interfaces out. This allows you to evolve / add these interfaces independently, instead of having to redo an entire class. I'd need more examples of this in code.\n\n\n\n"
    }
  ]
}