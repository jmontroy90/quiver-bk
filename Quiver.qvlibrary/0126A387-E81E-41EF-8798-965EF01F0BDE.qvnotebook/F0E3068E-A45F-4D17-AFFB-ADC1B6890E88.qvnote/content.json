{
  "title": "Transport Layer Security (TLS)",
  "cells": [
    {
      "type": "markdown",
      "data": "TLS operates above TCP and below the Application layer, in the Session layer. That means that Application protocols like HTTP don't have to worry about TLS.\n\nHTTP/2 requires TLS 1.2.\n\nSSL == TLS. SSL is what Netscape called it, and TLS is the IETF name.\n\nTLS provides three things:\n* **Encryption** - A mechanism to obfuscate what is sent from one host to another.\n    * Think cipher suites, asymmetric public key exchange (via RSA, Diffie-Hellman) followed by symmetric key exchange for AES.\n* **Authentication** - A mechanism to verify the validity of provided identification material.\n    * Think Certificates, Chain of Trust, Certificate Authorities\n* **Integrity** - A mechanism to detect message tampering and forgery.\n    * Think checksums,  message authentication codes (MACs)\n\nThere's a TLS Handshake on top of the basic TCP handshake:\n![IMAGE](quiver-image-url/8541F9019370A723554071175BD8FC45.jpg =402x300)\n\nWith TCP, this is three full round trips before any data is exchanged!! Luckily, we can do a lot better.\n\n**Application Layer Protocol Negotiation (ALPN)** is a way to embed an application protocol used for the ensuing data exchange into your TLS handshake (e.g. HTTP, SPDY, FTP, IMAP). Without this, you'd have to send traffic over well-known ports corresponding to protocols. With this, you can send over one port (HTTPS) and negotiate the protocol during the TLS handshake.\n\n**Server Name Indication (SNI)** is a way to have a single node serve multiple host names and their corresponding certificates. The `ClientHello` message of the TLS handshake embeds these multiple hostnames, and the whole thing resolves before HTTP is even involved.\n\n**TLS Session Resumption**\n\nIn order to reduce the TLS handshake overhead for repeated connections, TLS allows for `Session Identifiers` to reuse prior TLS information for repeated, uniquely-identified clients. This eliminates a full round trip, but mandates the server to maintain a session identifier cache.\n\nTo do it client-side, we use `Session Tickets` to pass encrypted session information to the client, to be included in their subsequent requests (until the ticket expires).\n\nIdentifiers are \"session caching\", and tickets are \"stateless resumption\"."
    }
  ]
}