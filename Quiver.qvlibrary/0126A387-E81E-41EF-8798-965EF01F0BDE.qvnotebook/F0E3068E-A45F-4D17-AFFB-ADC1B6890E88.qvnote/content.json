{
  "title": "Transport Layer Security (TLS)",
  "cells": [
    {
      "type": "markdown",
      "data": "TLS operates above TCP and below the Application layer, in the Session layer. That means that Application protocols like HTTP don't have to worry about TLS.\n\nHTTP/2 requires TLS 1.2.\n\nSSL == TLS. SSL is what Netscape called it, and TLS is the IETF name.\n\nTLS provides three things:\n* **Encryption** - A mechanism to obfuscate what is sent from one host to another.\n    * Think cipher suites, asymmetric public key exchange (via RSA, Diffie-Hellman) followed by symmetric key exchange for AES.\n* **Authentication** - A mechanism to verify the validity of provided identification material.\n    * Think Certificates, Chain of Trust, Certificate Authorities\n* **Integrity** - A mechanism to detect message tampering and forgery.\n    * Think checksums, message authentication codes (MACs)\n\nThe usual TLS handshake involves the RSA algorithm, where the client uses the server's (authenticated) public key to encrypt a symmetric key for the session. The server then decrypts using its private key. In RSA, if someone records your encrypted sessions, and later gains access to the server private key, they can still decrypt everything **because the symmetric key is physically exchanged between the two hosts**! However, Diffie-Hellman + ephemeral session keys allows for _perfect forward secrecy_ -- the server's private key is still used, but the symmetric session key never actually leaves the host. The \"ephemeral session keys\" means that each session negotiates a new symmetric key -- no prior data can be logged and later unencrypted! As such, RSA is being slowly phased out.\n\nThere's a TLS Handshake on top of the basic TCP handshake:\n![IMAGE](quiver-image-url/8541F9019370A723554071175BD8FC45.jpg =402x300)\n\nWith TCP, this is three full round trips before any data is exchanged!! Luckily, we can do a lot better.\n\n**Application Layer Protocol Negotiation (ALPN)** is a way to embed an application protocol used for the ensuing data exchange into your TLS handshake (e.g. HTTP, SPDY, FTP, IMAP). Without this, you'd have to send traffic over well-known ports corresponding to protocols. With this, you can send over one port (HTTPS) and negotiate the protocol during the TLS handshake.\n\n**Server Name Indication (SNI)** is a way to have a single node serve multiple host names and their corresponding certificates. The `ClientHello` message of the TLS handshake embeds these multiple hostnames, and the whole thing resolves before HTTP is even involved.\n\n**TLS Session Resumption**\n\nIn order to reduce the TLS handshake overhead for repeated connections, TLS allows for `Session Identifiers` to reuse prior TLS information for repeated, uniquely-identified clients. This eliminates a full round trip, but mandates the server to maintain a session identifier cache.\n\nTo do it client-side, we use `Session Tickets` -- use a private server key to encrypt and send session information from the server to the client, to be included in the client's subsequent requests (until the ticket expires). \n\nIdentifiers are \"session caching\", and tickets are \"stateless resumption\".\n\n**Chain of Trust**\n![IMAGE](quiver-image-url/D761111BF2208CC8C06E6B886B79F441.jpg =300x106)\nBasically, an X.509 cert contains the public key, some identifying ownership data, and info on the issuer / verifier: their CA name, and their signature affirming they trust this cert."
    }
  ]
}