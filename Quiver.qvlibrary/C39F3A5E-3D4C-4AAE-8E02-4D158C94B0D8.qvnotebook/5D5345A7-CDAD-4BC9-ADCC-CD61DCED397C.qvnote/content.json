{
  "title": "Controlling the go runtime",
  "cells": [
    {
      "type": "markdown",
      "data": "[Link to video](https://www.youtube.com/watch?v=us9hfJqncV8)\n\nThe Go runtime is anything under the Go SDK's `runtime` package. This includes:\n* garbage collector\n* goroutine scheduler\n\nThis doesn't include things like `fmt` -- they're part of the Go SDK, but need to be imported to make it into runtime. The stuff above is ALWAYS in your runtime.\n\nLots of stuff about profiling, debugging, and tracing.\n\nThe focus of this talk are things that the developer can use to affect the behavior of the above stuff, e.g. garbage collection and goroutine scheduling.\n\n### Garbage Collector\n* `GC()` -- start garbage collecting now, block until finished\n* `KeepAlive(obj)` -- don't garbage collect this obj\n* `SetFinalizer(obj, f)` -- run the function f when obj is garbage-collected\n\n### Scheduler\n* `GOMAXPROCS(n)` -- set maximum simultaneously executing processors\n* `Goexit()` -- terminate calling goroutine\n* `Gosched()` -- yield caller's processor, letting other goroutines to be scheduled on it\n* `LockOSThread()` / `UnlockOSThread()` -- bind calling goroutine to its current OS thread (instead of switching stacks around behind the scenes!)\n\nA few more:\n![IMAGE](quiver-image-url/6C2D07A5AC0E849493FF78D55576CD14.jpg =409x255)\n\n### Misc. Examples\n* Note that any context `ctx` that has `cancel()` called on it will cancel all goroutines that has that context. This is similar to stuff above, just indirectly.\n* You also use `Goexit()` all the time -- `t.Fatal(...)` uses it.\n* `go test --cpu 1,2,4` uses `GOMAXPROCS(n)` behind the scenes.\n* `LockOSThread()` is good for things with thread-local state -- Unix signal handling, the Golang OpenGL library, etc.\n* `GC()` can be used to see how the garbage collector performs under different allocation methods, in other words good for benchmarking!\n* `KeepAlive(obj)` is used, for example, to make sure a file descriptor isn't GC'd while a blocking system call goes out.\n\nIn summary:\n![IMAGE](quiver-image-url/CE426F5EFF3DE447C5017B1CF67722E9.jpg =633x358)\n\nThe rest of his talk is about some proposed runtime controls -- mostly around the idea of thread colors and affinities, e.g. \"all threads of this type (color) should be cancelled, or scheduled all on the same CPU to reduce L1 / L2 cache misses\".\n"
    }
  ]
}