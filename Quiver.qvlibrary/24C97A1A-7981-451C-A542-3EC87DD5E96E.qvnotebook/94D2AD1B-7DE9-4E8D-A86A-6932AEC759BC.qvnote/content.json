{
  "title": "Contexts",
  "cells": [
    {
      "type": "markdown",
      "data": "The package docstring really says it nicely:\n> Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.\n\nExample values: end user identifiers, auth tokens, loggers, metrics; be careful on differentiating request-scoped metadata versus genuine arguments to functions.\n\nAny set of goroutines that take the same (derived) context can all be cancelled / timed out at once, releasing needed resources immediately.\n\nIt's **NOT** for carrying optional arguments.\n\nIt's **NOT** for storing in a struct -- it's request-scoped, so by definition it's an argument, and by convention it's the first argument adds `ctx context.context`.\n\nDo **NOT** pass `nil` as a context -- use `context.TODO` if you're not sure what context to use yet.\n\nWe use it for HTTP request loggers, metrics, and specific pipeline values for requests. Most HTTP Request / Response objects deal with it either indirectly or directly, so remember to pass it into your dependency libraries too!\n\nDeadlines and cancellations apply to both the immediate context as well as any derived contexts (so, children but not parents -- it's one way.)\n\nThink: a server takes requests that have a Context (or not). We can get or create a context as a server for that request. And we can attach the context when we write a response.\n\nQuestion: how do we safely unmarshal contexts across differing library implementations? Do we rely on convention?\n\n## Usage\n`context.Background()` is an empty context that is never cancelled and has no deadline. It's used for initialization, tests, and top-level inits for incoming requests.\n`context.TODO()` is the same, but should be used as a marker for where context will go if it's not available yet.\n\n`ctx.Done()` returns a channel, so any time we're dealing with contexts for cancellation / deadlines, we're gonna be doing `select` between competing goroutines:\n```\nreq = req.WithContext(ctx)\ngo func() { c <- f(http.DefaultClient.Do(req)) }()\nselect {\ncase <-ctx.Done():\n    <-c // Wait for f to return.\n    return ctx.Err()\ncase err := <-c:\n    return err\n}\n```\nHere, the `ctx` has a timeout attached to it that will be used on the `Do(req)` call. Note the `<-c` call in the first branch -- the client cancels, but still has to return, so we wait for that, not the request itself."
    }
  ]
}