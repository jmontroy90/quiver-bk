{
  "title": "Projector Layout",
  "cells": [
    {
      "type": "markdown",
      "data": "# Layout of Projectors/ Projector Sets... An experiement in documentation\n\nA projector represents the smallest processor of work in a Mystique pipeline. In theory Projectors make no assumption as to the platform that they execute on and contain a single methog `process`. A projectorSet is what provides the basic grouping and context to a projector. Throughout the mystique codebase there are many instances of projectors and projector sets. In order to properly integrate with them properly we attempt to list each one and examine functionality surrounding its usage. \n\n## BaseProjector - BaseProjector.scala\n### Dependencies\nThis is the most basic `Projector` in the MCL and has no dependencies.\n### Added functionality?\nIntroduces the notion of `process` whih is the most basic function in our processing pipeline. It takes an `Input` and transforms it to an `Output` with no concern for the transformations. These can be batches of work or streams. This implies that the BaseProjector can be used to build non Spark/non distributed workflows.\n### Use cases\nEverything starts here.\n### Extra Notes\nIntroduces the `Conn`, `Input`, `Output`, and `Conf` type members which are used extensively later in the pipeline. \n\n---\n\n## CassandraProjector - CassandraProjector.scala\n### Dependencies\n`BaseProjector`\n### Added functionality?\nIntroduces the `changeStreamTopic`. Also introduces all of the row writing functionality needed to work with Cassandra. The type members introduced earlier are tied to Spark and cassandra specific types. \n### Use cases\n### Extra Notes\nIt seems that this Cassandra Projector is used everywhere however it seems strange that we look ourselves in to a very specific implementation so low in the infra. Also a `produceChangeStream` function is introduced which should have nothing to do with cassandra? **Important to note that `changeStreamTopic` is defined at this level and is different for each Projector.** Also even though none of the features are used at this level, This projector introduces a dependency on the `BaseGorillaGroddConfig`. While not needed in the code if we do a deep integration at the Projector level we can grab configs and args here as well. \n\n---\n\n## ExplicitProjector - ExplicitProjector.scala\n### Dependencies\n`CassandraProjector`\n### Added functionality?\nDefines the `process` functionality; it actually introduces the steps that each projector must take when it recieves data. Adds the `selectExpressions` member which contains the data that we want to grab from the incomming kafka messages. \n### Use cases\nIt seems that everyone that writes grodd projectors extends the `ExplicitProjector` classs. \n### Extra Notes\nThere is weird functionality sharing betwen the cassandra projector and the explicit projector. I am not so sure that the cassandraProjector really needs to be a projector. It could be something else that provides cassandra related functionality but there is no obvious reason why it is a projector. **`selectExpressions` is incredibly important.**\n\n---\n\n## MartListener - MartListener.scala\n### Dependencies\n`CassandraProjector`\n### Added functionality?\nUsers define some implementation of the `BaseUDF`. Martlisteners listen to kafka streams apply the transformation defined above, publish a change stream message(implying that they have `changeStreamTopic` defined) and save to cassandra. \n### Use cases\nIt seems that everyone that writes grodd martlisteners extends the `MartListener` classs. \n\n---\n\n## SparkSqlJsonProjector - SparkSqlJsonProjector.scala\n### Dependencies\n`BaseProjector`\n### Added functionality?\n`query` is introduced but not defined; this is the sql statement that spark runs on each batch.  \n### Use cases\nExtending this trait gives you the behavior of parsing an RDD[String] of JSONs from a source schema to a dest schema via\na Spark SQL statement. The point is for to start and finish with RDD[String] of JSONs.\n"
    }
  ]
}