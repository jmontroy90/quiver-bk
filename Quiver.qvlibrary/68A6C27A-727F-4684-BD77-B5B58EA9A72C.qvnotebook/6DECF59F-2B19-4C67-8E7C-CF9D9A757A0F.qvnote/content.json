{
  "title": "Logging",
  "cells": [
    {
      "type": "markdown",
      "data": "## Logging Levels\nMost people need logging in two scenarios:\n* `debug` -- tell me everything, I'm writing code or fixing a bug\n* `info` -- tell me what happens, high-level. `info` contains `error`.\n\n## Global or Local?\nPassing through loggers can be an irritating thing.\n* Do you need to control logging from struct to struct, or class to class?\n* Do you need to change levels?\n* Scala did a lot of injection of lazy vals via traits, Go sometimes has package-global state.\n\n## State Management\nHow do we manage call stacks? Fields for structured logging?\n\nLoggers like Apex allow us to include Fields on our logger as state to be included in all subsequent calls. This is a bit of mutability that can be tricky to manage.\n\n## Handlers\nLogs need middleware too. A simple `Handler` interface (like what Apex/log does) can help you register these handlers, which can manage text, sockets, JSON, \"discard\", etc.\n\n## Structured Logging\nStructured logging is best because we can index and query on structured KV fields. It's like querying a database of logs, more machine-friendly for things like Splunk. Further, constructing errors with variable names embedded in them makes the errors **NOT** machine-friendly -- think of all the wildcards you have to add to your string searches, and how much complexity that adds. Any variables needed should be fields in your structured logs, which can be separately faceted against.\n\n## Runtime\nYou should 100% be able to modify log levels / other important logging details at runtime. This can be a route that accepts some sort of JSON payload to merge with the currently running application state. Other params you might want to modify include different HTTP request management settings."
    }
  ]
}