{
  "title": "proto3 spec",
  "cells": [
    {
      "type": "markdown",
      "data": "protobuf - proto3 spec:\n\n```\nsyntax = \"proto3\";\n\nmessage SearchRequest {\n  string query = 1;\n  int32 page_number = 2;\n  int32 result_per_page = 3;\n}\n```\n\nNote - numbered fields, required vs. optional. All scalar types, composite ones come later.\n\n**Tags** - 1 byte for numbers 1 - 15, and 2 bytes for tags 16 - 2047. \n* So if you use a low tag number for an optional field, you've done something wrong.\n* Also - leave room  for additional frequently occuring fields in the future in your low tag numbers!\n* 5k messages / second for 50 jobs = 21.6gb additional space per day per poorly labelled tag!\n\n**Singular** and **repeated** for field frequency - singular is {0,1}, and repeated is an ordered {0,N}\n* repeated numerics are \"packed\" by default, which is an encoding thing\n* proto3 got rid of required! I'd say follow that wind.\n\nMultiple message types can be defined in one .proto file (message, enum, service) for grouping purposes, but this can lead to dependency bloat.\n\nYou can have a **reserved** keyword for certain tag numbers if you don't want them to be re-used in the future!\n\n```\nmessage Foo {\n  reserved 2, 15, 9 to 11;\n  reserved \"foo\", \"bar\";\n}\n```\n\nData type notes:\n* use \"sint32\" instead of \"int32\" for fields likely to have negative numbers\n* \"sfixed32\" - signed fixed (always four bytes), good for fields that typically are larger than 2^28\n* string - UTF8\n\n\n**Optional field** defaults by type (when some other type-specific default is not provided) - worth knowing:\n* string = \"\"\n* bool = false\n* numeric = 0\n* enums = first value listed in enum definition, must be zero (SO BE CAREFUL WHEN MIGRATING AN ENUM'S DEFINITION!!)\n* bytes = empty bytes\n* repeated fields - empty list (in the appropriate language)\n\nThings chosen to default don't serialize on the wire. Also, there's no way to differentiate a default from a hard-coded match to the default.\n\n`optional int32 result_per_page = 3 [default = 10];`\n\n**Enums** - numbering fields within an enum for more safety! Can specify enum aliases for overloading, just need an option to allow it.\n* There MUST be a zero value in your enum for defaults.\n\n```\nmessage SearchRequest {\n  required string query = 1;\n  optional int32 page_number = 2;\n  optional int32 result_per_page = 3 [default = 10];\n  enum Corpus {\n    UNIVERSAL = 0;\n    WEB = 1;\n    IMAGES = 2;\n    LOCAL = 3;\n    NEWS = 4;\n    PRODUCTS = 5;\n    VIDEO = 6;\n  }\n  optional Corpus corpus = 4 [default = UNIVERSAL];\n}\n```\n\nYou can import proto definitions from other files, and create more or less symbolic links from old files to new files in a different location. Another thing to ease migrations!\n\nYou can also nest message types and reference those accordingly.\n\n```\nmessage SearchResponse {\n  message Result {\n    required string url = 1;\n    optional string title = 2;\n    repeated string snippets = 3;\n  }\n  repeated Result result = 1;\n}\n```\n\nUpdating your message type:\n* Added fields are read by your new code using defaults when not present in a message; old code will just ignore new fields.\n* Remove fields by renaming with \"OBSOLETE_\" or adding the \"reserved\" keyword.\n* int32, uint32, int64, uint64, and bool are forward/backward compatible\n* sint32 and sint64 are compatible with each other AND NOTHING ELSE\n* string and bytes are compatible if the bytes are UTF8\n* Some other details, not crazy important\n\nUnknown fields are NOT available upon deserialization, even if the deserialization is successful.\n\n**Any** type - ability to fetch and unpack / pack any protobuf message at runtime, to then be used and parsed more specifically, I guess. Sorta like generics? Example (is this...C++?):\n\n```\nErrorStatus status = ...;\nfor (const Any& detail : status.details()) {\n  if (detail.Is<NetworkErrorDetails>()) {\n    NetworkErrorDetails network_error;\n    detail.UnpackTo(&network_error);\n    ... processing network_error ...\n  }\n}\n```\n\n**Oneof** - only one field of a list of possible fields will be set at any given time (shares underlying memory). Not sure when you'd use this, isn't it like an enum?\n\n**Maps** - map<string, Project> projects = 3;\n* Can't be repeated\n* Not ordered on the wire\n\n**Options** - only notable ones I've seen:\n* optimize_for (file option): Can be set to SPEED, CODE_SIZE, or LITE_RUNTIME. We should do speed.\n\n**Proto3** - supports JSON mappings! Just class/method calls within a particular language's library."
    }
  ]
}