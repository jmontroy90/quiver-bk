{
  "title": "How the Kernel Manages Your Memory",
  "cells": [
    {
      "type": "markdown",
      "data": "[Link to article](http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory/)"
    },
    {
      "type": "markdown",
      "data": "Remember, all processes manage their own virtual memory space with their own page tables to map to physical memory. With this in mind, here's a running process:\n![IMAGE](quiver-image-url/22F08103F52275ACA42FAA2A20135050.jpg =558x325)\nWe're back in the land of descriptors:\n* The process descriptor is an instance of `task_struct`, and has a field `mm` with a pointer to its memory descriptor\n* The memory descriptor is an instance of `mm_struct`, which stores beginnings/ends of memory segments (like the `stack`, `heap`), number of physical memory page frames allocated to the process (`rss` ie Resident Set Size), the amount of virtual memory, and other metadata.\n\nThe two most important components of a memory descriptor are:\n1) A linked list of virtual memory areas (`VMA`), which are instances of the `vm_area_struct`. Each one corresponds (\"anonymously\") to exactly one virtual memory segment (ie `heap`) EXCEPT for ones corresponding to files in the memory mapping segment.\n2) `Page tables` which map virtual addresses into physical addresses. Each process has its own set of page tables, so page tables are swapped out given a context switch.\n\nThe memory areas of a process (and corresponding structs) look like the following:\n\n![IMAGE](quiver-image-url/195FCE8852B1CE2536630B81768D0FDC.jpg =587x533)\n\nThe `mmap()` linked list containing all VMAs is implemented as a [red-black tree](http://en.wikipedia.org/wiki/Red_black_tree) in Linux and as an [AVL tree](http://en.wikipedia.org/wiki/AVL_tree) in Windows. The cmd `/proc/<pid>/maps` simply navigates this tree and prints the contents of each node.\n\nVirtual memory is divided into `pages` - both Linux and Windows map virtual memory into 4k pages. Therefore, all VMAs are multiples of this page size.\n\nThese virtual pages are mapped to page table entries (`PTE`) in the page table. One PTE looks like:\n![IMAGE](quiver-image-url/3571B414D8274CB9FAF5B3962AA4E50D.jpg =669x75)\nThese flags / bits set various things:\n* `P` for present in physical memory (Linux is lazy)\n* `R/W` for read / write\n* `U/S` for permissions (user / supervisor)\n* `D` for dirty (written) and `A` for accessed (either read or written)\n* `Physical address`, aligned to 4k memory locations.\n\nSince the PTEs of different processes can map to the same physical page frame, permissioning can vary across processes. Note that an `execute` permission ISN'T on the PTE, which leads to some trouble.\n\nThe base physical address maps into physical memory into a given `page frame` - the page frame is the _unit of physical memory management_. Both Windows and Linux use 4k page frames by default. Page frames are:\n* Allocated using [buddy memory allocation](http://en.wikipedia.org/wiki/Buddy_memory_allocation)\n* `anonymous` (program data) or part of the `page cache` (caching IO data)\n\nHere's a breakdown from the VMAs to page frames:\n![IMAGE](quiver-image-url/7A17A10EF159E63EC0432AA15C34A73F.jpg =549x176)\n\nLast but not least - the kernel is **LAZY** in its page frame allocation. It doesn't actually allocate a page frame to be corresponded with a PTE (the PTE `present` flag set) until a page fault is incurred by some requesting application. This process looks like this:\n\n![IMAGE](quiver-image-url/1DC5B56330EC5A20A2318BB908234EBF.jpg =678x402)"
    }
  ]
}