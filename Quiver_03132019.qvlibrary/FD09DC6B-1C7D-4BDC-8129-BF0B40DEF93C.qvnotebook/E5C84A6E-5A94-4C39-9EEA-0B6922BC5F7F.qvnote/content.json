{
  "title": "Anatomy of a Program in Memory",
  "cells": [
    {
      "type": "markdown",
      "data": "[Link to article](http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/)"
    },
    {
      "type": "markdown",
      "data": "Every process has its own `virtual memory space`, which means a translation into a physical address via page tables / the lookaside buffer needs to occur. These virtual memory spaces are 4GB on a 32-bit OS, and are enabled for EVERY process, including kernel processes.\n\nStoring kernel code and data in the virtual memory space of a process is unfortunate overhead. This space is allocated but typically not fully used.\n\nHowever, kernel memory mappings are static for all processes, so when a context switch occurs, the new virtual memory user-mode space will be swapped in with the same kernel memory mappings.\n![IMAGE](quiver-image-url/E3D3A26C60E5CD86B5332150EC8BD00B.jpg =625x152)\nNote that these segments simply correspond to areas of main memory like the `stack`, the `heap`, `bss`, and so on, which we'll review now. They have _nothing_ to do with Intel segments used for segmentation.\n\nThe normal memory layout for a Linux process:\n![IMAGE](quiver-image-url/0714D6ACB1093F381791A4A2D7F6B7C5.jpg =696x570)\nWe know about the stack (stack frames allocated on method invocations in a LIFO fashion) and the heap (shared memory access subjected to GC (manual or runtime-managed). \n\nStack growth is managed via calls to `expand_stack()` (which in turn calls `acct_stack_growth()` to check if the stack is exceeding `RLIMIT_STACK`). Heap growth is managed via the `brk()` function, and allocations are performed either via `malloc()` or the `new` keyword, depending on your language (Scala omits the `new` keyword for case classes).\n\nThe `memory mapping` segment is where file memory maps (via the `mmap()` call) are stored - this speedier memory access over incurring IO is useful for loading libraries dynamically. You can also do anonymous memory mappings for program data - an application `malloc()` call will allocate in the memory mapping segment for allocations greater than `MMAP_THRESHOLD`. \n\nFinally, the bottom segments (`bss`, `data`, `text`) break down as follows:\n* `bss` and `data` both hold static variables - `bss` is uninitialized, and `data` is initialized. These memory segments are all in the spirit of globals.\n  * `data` _technically_ maps files (since it maps initialized statics in your source code), but it's a private memory mapping that has no obligation of synchronization to its originating file.\n* The `text` segment stores your code source and some literals referenced by pointers in the `data` segment.\n\nOne last useful command - examine the memory segments of a program by its PID via: `/proc/<pid>/maps`."
    }
  ]
}