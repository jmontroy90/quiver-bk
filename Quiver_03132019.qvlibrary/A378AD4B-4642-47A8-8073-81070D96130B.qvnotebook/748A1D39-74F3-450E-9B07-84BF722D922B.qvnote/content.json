{
  "title": "Data Models and Query Languages",
  "cells": [
    {
      "type": "markdown",
      "data": "### Relational Model Versus Document Model\n\nData is organized into relations (tables) of unordered tuples (rows). RDBMSes have survived wave after wave of technologies, going from their humble transaction processing roots to power a lot of what the internet is.\n\nEnter NoSQL (\"not only SQL\"), which offers:\n* Greater scale-out capabilities\n* Better expressiveness for more complex schemas\n* A preference towards open source\n\nStill, one should have no strict preference - _polyglot persistence_ is the way of the future.\n\nFor object-oriented languages on top of relational databases, there is an **impedance mismatch** - translate between the object's fields and the schema of the related table. ORM libraries like Hibernate try to make this easier, but it still sucks.\n\nTypical one-to-many relationships in your data model are expressed by joins in a relational model, which implies a tree structure. JSON representations simply make this explicit by allowing for nested and multi-valued fields. (arrays containing objects containing... ).\n\nThe other monkey wrench is the idea of _normalization_ - relational databases use joins to look up the value corresponding to a numerical key in the fact table (more or less). These relationships are many-to-one (imagine looking up the home state of all users, where the actual state name \"New Jerey\" is stored in a lookup / dim table). Thus they're more difficult for a document model to express. Document models have one-to-one just fine, and one-to-many via nested arrays. \n\nDocument models typically work with JSON-esque data structures, and have the option for join / normalization scenarios of either:\n* Denormalizing in memory by pulling dim tables into the application\n* Carrying around more state / fields instead of relying on joins somewhere (not applicable for a normalization scenario)."
    },
    {
      "type": "markdown",
      "data": "\nNormalization does help on reducing duplication and easing updates with many-to-one joins, which the document model has a hard time with.\n* Think: how would you join JSONs to resolve an ID? JSON events for example aren't stateful\n* Maybe you pull it into app code? Dim tables can be small, but there are limits!\n\nDocument vs. relational, which one to use? IF you have events with a lot of one-to-many relationships, document. Lots of many-to-one - maybe relational! But they're not mutually exclusive at all.\n\nDocument models are kind of \"schema-on-read\", whereas relational is on write and requires migrations to new schema that are expensive. You can do a bunch of nullability for flimsy schema, and get some performance enhancements. But document allows for much easier migrations. Data locality can be easier for (stateful, one-to-many) documents, since no joins. But relational can get around that with \"table families\".\n >A hybrid of the relational and document models is a good route for databases to take in the future.\n \nThink MySQL, PostgreSQL, DB2, supporting XML / JSON data structures in tables.\n\n#### Querying \nQuerying of models is generally done by imperative query languages -- leave implentation to the system, and just describe your results!\n\n#### Graph Models\nAll graph models consist of vertices (nodes) and edges. There are two main graph models: property graphs (Neo4j) and triple-store (Datomic).\n\n#####Propery graphs:\nVerticies are KV properties with an id, and edges are directed with a label and properties. The schema is obviously loose (any node to any node with any labelled relationship via an edge). This is pretty easy to evolve, but involves traversal. I'm assuming data locality here gets sticky.\n\nCypher example:\n\n```\nMATCH\n(person) -[:BORN_IN]->  () -[:WITHIN*0..]-> (us:Location {name:'United States'}),\n(person) -[:LIVES_IN]-> () -[:WITHIN*0..]-> (eu:Location {name:'Europe'})\nRETURN person.name\n```\n\nNote the RegEx-esque `:WITHIN*0` - this is a traversal of 0 to N nodes, which could only be modeled relationally by CTEs.\n\n#####Triple-store:\n\n`(subject, predicate, object)`\n\nIf the object is primitive, it sets a property on the subject. If it's another object, it's a graph connection between nodes.\n\n```\n@prefix : <urn:example:>.\n_:lucy     a       :Person.\n_:lucy     :name   \"Lucy\".\n_:lucy     :bornIn _:idaho.\n_:idaho    a       :Location.\n```"
    }
  ]
}