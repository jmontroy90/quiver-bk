{
  "title": "Generalized type constraints in Scala (without a PhD)",
  "cells": [
    {
      "type": "markdown",
      "data": "[Link to article](http://blog.bruchez.name/2015/11/generalized-type-constraints-in-scala.html)"
    },
    {
      "type": "markdown",
      "data": "Common operator in Scala:\n> def flatten[B](implicit ev: A <:< Option[B]): Option[B]\n\nWhat is the `<:<` (and corresponding `=:=`) -- and how is it different from `<:` and `>:`?\n\nIn words, `T1 <:< T2` means \"Make sure that T1 is a subtype of T2, or else report an error.\"\n\nSo in the `flatten` case on Option, we want to ensure that the inner type of what we're invoking `flatten` on is a subtype of `Option[B]`. In terms of what `flatten` is doing - peel back one layer of nesting - this makes sense.\n\nAnother example - `toMap` on a `Traversable`: \n>def toMap[K, V](implicit ev: A <:< (K, V)): Map[K, V]\n\nThis also makes pretty intuitive sense: when converting a Traversable to a Map, ensure that each element is a subtype of a key-value tuple.\n\nThis makes sense, but the articles questions (below) are the right ones:\n\n1) Can’t we just use type bounds which I thought existed to enforce this kind of type constraints?\n2) If this is a pattern rather than a built-in feature, why does <:< look so much like an operator? Does the compiler have special support for it?\n3) How does this whole thing even work?\n4) Is there an easier ways to achieve the same result?"
    },
    {
      "type": "markdown",
      "data": "**Can’t we just use type bounds which I thought existed to enforce this kind of type constraints?**\n\nLong story short - remember this puzzler.\n\nFor function:\n> def tupleIfSubtype[T <: U, U](t: T, u: U) = (t, u)\n\nWhat does this invocation return as the types of `T` and `U`?\n\n> tupleIfSubtype(\"Lincoln\", 42)\n\nThe answer is:\n> (String, Any)\n\nWith these type bound operators, Scala's type inference will reconcile these two types in a rather lenient and useless way. The process is:\n1) `T` is a `String`.\n2) `U` is an `Int`.\n3) The only common type ancestor a `String` and `Int` have is `Any`. \n4) Therefore `T` keeps its specific type as a sort of \"best case scenario\", and because `U` must be a parent type to `String`, the only option for it is `Any`.\n\n**Why does <:< look so much like an operator?**\n\nIt's an infix type. `A <:< B` == `<:<[A,B]`. If an implicit something is found that defines an object with type `<:<[A,B]`, we're good to go. Likely this is auto-generated at compile time / available at runtime for any inheritance relationship.\n\nRemember also that Scala method definitions scope types across parameter lists. So in the method signature:\n> def tupleIfSubtype[T, U](t: T, u: U)(implicit ev: T <:< U) = (t, u)\n\nThe `T` and `U` of both argument lists are bound together.\n\n**How does this whole thing even work?**\n\nTake a look in `scala.Predef` for the definition of `<:<[A,B]`:\n```scala\n@implicitNotFound(msg = \"Cannot prove that ${From} <:< ${To}.\")\nsealed abstract class <:<[-From, +To] extends (From => To) with Serializable\n\nprivate[this] final val singleton_<:< = new <:<[Any, Any] { def apply(x: Any): Any = x }\n\nimplicit def $conforms[A]: A <:< A = singleton_<:<.asInstanceOf[A <:< A]\n```\n\nThe implicit we need is provided by `$conforms[A]`, which creates an instance of `<:<` via the singleton `apply`. It is then cast to <:<[A,A], which must _conform_ to <:<[T,U]. How does it conform to that type? Via type constraints on the `<:<` class, which extends `Function1`!\n\nThis gets tricky. Given that `Function1[-From, +To]` has variance as such, how can a function of `A => A` conform to a function of `T => U` with the given variance? Well, A must be a supertype of `T` / `From` and a subtype of `U` / `To` -- in other words:\n> T <: A <: U\n\nThe slam dunk:\n>\"To summarize the reasoning: the only eligible implicit definition in scope which can possibly be selected by the compiler to pass to our function is selected if and only if T is a subtype of U! And that’s exactly what we were looking for!\"\n\nUnfortunate how complex this, and that the `asInstanceOf` call is unavoidable. But otherwise, this makes sense. The implicit is provided via a type-constrained singleton generator that creates an instance of `<:<`.\n\nAll this ultimately boils down to the provided evidence `ev` being used as an implicit conversion. Check your types:\n> def tToU[T, U](t: T, u: U)(implicit ev: T <:< U): U = t\n\n**Is there an easier ways to achieve the same result?**\n\nNot really."
    }
  ]
}