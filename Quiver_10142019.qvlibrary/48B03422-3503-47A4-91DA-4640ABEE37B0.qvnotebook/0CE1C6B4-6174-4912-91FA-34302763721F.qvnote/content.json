{
  "title": "Chapter 2: Predictable Demands",
  "cells": [
    {
      "type": "markdown",
      "data": "A couple of normal ideas with k8s-specific terminology.\n\n#### Runtime Dependencies\nYour persistent volumes, your ports, and your config. Declare them up front. For config, you have `ConfigMap` objects, but also `Secret` objects for, uh, secrets.\n\n#### Resource Profiles\nBasic distinction: _compressible_ vs _incompressible_. Memory is incompressible - when you're out, you're out. CPU or network bandwidth, however, is compressible -- more context switching or backpressure.\n\nFor a given pod, your `requests` are resource minimums and `limits` the maximums. `requests` dictate whether your Pod can be successfully scheduled on a Node. \n\nA Pod with no requests or limits will be considered _Best-Effort_, e.g. when incompressible resources are exhausted, these Pods die first. With specified `requests` > `limits`, a Pod is `Burstable` -- these die second. If `requests` == `limits`, the Pod is `Guaranteed` and dies last under incompressible resource exhaustion. These all outline what's called **Quality of Service**\n\n#### Pod Priority\n`Pod Priority` is also available to help eviction policies - low-priority Pods can be evicted on behalf of high-priority ones. QoS and Pod Priority have interesting orthogonal overlap -- QoS is more for erfroamcne under resource exhaustion, and priority more for ordering your service's importance for scheduling and eviction. Priority is easy to game.\n\n#### Project Resources\n`ResourceQuotas` can limit total namespace resources, including things like ConfigMaps and Services. `LimitRanges` can keep your request-limit ratio under control.\n\nAll this stuff will vary from namespace to namespace. Your prod namespace, for example, might just have Guaranteed QoS with a well-defined order of Pod Priorities.\n\nSpecifying your requests and limits is not mandatory, but if you wanna use Kubernetes, you'd be dumb not to set them."
    }
  ]
}