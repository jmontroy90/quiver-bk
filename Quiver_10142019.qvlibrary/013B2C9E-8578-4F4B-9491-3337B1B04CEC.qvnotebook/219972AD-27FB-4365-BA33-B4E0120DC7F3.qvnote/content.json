{
  "title": "API Conventions",
  "cells": [
    {
      "type": "markdown",
      "data": "[Link to doc](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md)\n\nRereads:\n* Differing Representations\n\nThe Kubernetes API is RESTful and exposes standard verbs that conform to REST semantics. The API prefers JSON and is schematized according to the `kind` and the `apiVersion`. `Group-Version-Kind` schemas are grouping by a group (`batch.k8s.io`), a version (`v1beta`), and a kind (`pod`). The `apiVersion` is the group and version put together. The API deals with URIs built out of this GVK information. Resources in k8s evolve together in terms of versioning, which is why this works the way it does.\n\nA single instance of a GVK is an `element` belonging to a particular `resource` (which is a GVK - think like oil being a resource). They can be retrieved as individual elements or collections. \n\n### Types (Kinds)\n\n`Objects` are persistent entities in the system, records of intent. They might consist of multiple resources, but k8s will try to create entities based on that object. Think `Pod`, `Service`, `Node`.\n\n`Lists` return collections of resources of one or more kinds.\n\n`Simple kinds` are usually transient subresources. They're used a lot to expose views of subentities on a given resource. They're found within their parent resource rooted at some point in the schema. Examples:\n* `/bind` -- used to bind resource A to resource B, e.g. `Pod` -> `Node`\n* `/status` -- affect just the status of a resource. For example, Pods don't let you modify the Spec or Metadata, but will expose `pods/<name>/status` to let you read AND write a pod's status.\n* `/scale` -- read and write resource count, independent of the resource it's attached to\n\n`meta` API objects like `ListOptions` also exist independently of groups that use them.\n\n### Objects\n\nAll objects must have a `namespace`, `name`, and `uid`. A `uid` is used to distinguish between objects with the same name and namespace that have been deleted and recreated.\n\nSome things they **should** have:\n* `resourceVersion` -- concurrency control, opaque to user, good for CAS-like operations\n* `generation` -- monotonically increasing integer specifying generation / version of object\n* `deletionTimestamp` -- set on request of graceful delete\n* `labels`, `annotations` -- queryable map and arbitrary metadata, respectively\n\n### Spec and Status\n\nThe Spec is the desired state -- the Status is the current state. k8s will try to move your object's status towards the spec, which is updated and changed immediately. k8s is level-triggered -- if you PUT a Node count from 2 -> 5 -> 3 quickly, the system will not \"check in\" at 5, it'll just aim for 3. This is all declarative, level-triggered resource / config management.\n\nPUT operations expect the whole object to be specified EXCEPT for the Status, which the PUT MUST NOT modify. Partial updates of spec can be done via read-modify-write with a GET, update in-memory, and PUT; OR it can be done with a PATCH. Concurrency control (re: `resourceVersion`, `generation`) comes in here.\n\nObjects whose Spec may not very can omit Status, and can also rename Spec to something else.\n\nSpec and Status can also mimic RPC-esque calls like `SubjectAccessReview`, where the Request is in the Spec, and the response is in the returned Status in the Response.\n\n### Status Conditions\n\nA normal field in the Status indicates some permanent, cross-cutting resource concern -- for example, \"podReady\" might be a field that applies to all pods. For statuses that may only apply conditionally or to a subset, Conditions can be used. They have a Type (`NodeReady`) and Status (`true`, e.g. this Condition applies) required, and then optionally things like Reason, Message, LastHeartbeatTime, and LastTransitionTime (e.g. when did this Condition change).\n\nStatus is not guaranteed to persist, and all is \"best effort\" stuff. Suitably sticky or large status should probably just be a separate resource. Loose coupling to other resources is best done via labels, or via `ObjectReference` if its to a specific object.\n\nDon't use enums (use aliased strings) or unsigned integers (varying library support), and avoid floats and bools.\n\n### PATCH Operations\nThere are three different PATCH operations:\n* **JSON Patch** (Content-Type: application/json-patch+json): establishes JSON operation like `add`, `remove`, `replace` with semantics defined by [RFC6902](https://tools.ietf.org/html/rfc6902).\n    * Example: `{ \"op\": \"add\", \"path\": \"/a/b/c\", \"value\": [ \"foo\", \"bar\" ] }`\n* **JSON Merge Patch** (Content-Type: application/merge-patch+json): partial representation that merges JSONs. You provide an input JSON and it replaces as needed, but unlike JSON Patch you aren't confined to individual ops OR replacing the whole resource like a generic PUT. RFC is [RFC7386](https://tools.ietf.org/html/rfc7386).\n* **JSON Strategic Merge Patch** (Content-Type: application/strategic-merge-patch+json): README is [here](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-api-machinery/strategic-merge-patch.md). A strategic merge patch allows for more intelligent merging of JSON lists -- normal patch semantics will only replace, whereas this can allow lists to be merged in a PATCH. Note that the default for strategic merge patch is `replace`, not `merge`, since `merge` needs a lot of info. This strategy is also definable in the OpenAPI spec, e.g. for CRDs. Go example:\n```\ntype PodSpec struct {\n  Containers []Container `json:\"containers\" patchStrategy:\"merge\" patchMergeKey:\"name\" ...`\n  ...\n}\n```\n\n### Idempotency\n\"All compatible Kubernetes APIs MUST support \"name idempotency\" and respond with an HTTP status code 409 when a request is made to POST an object that has the same name as an existing object in the system.\"\n\n`metadata.generateName` bootstraps off k8s' unique name generation. Not sure how to use yet.\n\n### Optional vs. Required\nHow-to:\n* `// +optional` comment tag\n* Go pointer type OR built-in nil (slices, maps)\n* Resource can be PUT or POSTed with this field unset\n\nThere's also `omitempty`, but empty vs. missing is different, so be careful. Prefer the optional comment if it truly is optional, even though `omitempty` will treat it like optional too for now.\n\nPointer values are useful to clarify optional vs. zero value scenarios too. Thus, use pointers for optionality.\n\n### Late Initialization\n```\nLate-initializers should only make the following types of modifications:\n\n1) Setting previously unset fields\n2) Adding keys to maps\n3) Adding values to arrays which have mergeable semantics (patchStrategy:\"merge\" attribute in the type definition).\n```\n\n### Concurrency Control and Consistency\nUse the `resourceVersion`! It's meant to help with CAS-like semantics on multiple-writers race conditions. Don't work with the `resourceVersion` directly -- implementation will change. Just GET it and hand it back opaquely on a new PUT, and if you fail for multi-write scenarios, retry with a new GET and whatever logic you need.\n\nCurrently this is backed by etcd's `modifiedIndex`. Also, `Watch` operations specify a `resourceVersion` to start the watch from.\n\n"
    }
  ]
}