{
  "title": "Slices",
  "cells": [
    {
      "type": "markdown",
      "data": "Slices are backed by arrays, so we start there.\n\n#### Arrays\nArrays specify length and element type. `[5]int` is a different type than `[6]int`. They're indexed from zero. The zero value of an array is a ready-to-use array whose elements are themselves zeroed.\n\nArrays are simply sequential memory. They're values -- no pointers involved unless you bring them. \"One way to think about arrays is as a sort of struct but with indexed rather than named fields: a fixed-size composite value.\"\n\nTwo forms of creating array literals, both with resulting types of `[2]string`. The `...` tells the compiler to count elements.\n\n```\nb := [2]string{\"Penn\", \"Teller\"}\nb := [...]string{\"Penn\", \"Teller\"}\n```\n\n#### Slices\n\nSlices have types like `[]string`, with no fixed length. Instead they rely on `make`, like: `func make([]T, len, cap) []T`. They're pointer-based e.g. reference types, and are backed by arrays.\n\nTheir zero-value is nil, since slices are reference types. A slice created by `var` instead of `make` will be a nil that can ACT like a zero-length slice (e.g. can append), whereas a `make` of length zero allocates memory. Note serialization issues though - a nil serializes to a JSON null, but a zero-length initialized slice to `[]`.\n\nInternally, they're a descriptor of an array segment, where they have a pointer to an element plus a length of segment and total capacity.\n\n![IMAGE](quiver-image-url/5443E4863FE968255B7E81F55E28D40E.jpg =517x193)\n\nA slice's length can't exceed its capacity, so copying and growing slices are common operations. The built-ins `copy` and `append` do this, where `append` just grows the slice as needed by copying to a slice backed by a bigger backing array (based on your input data).\n\n#### Gotchas\n\n* Returned slices that refer to some tiny subarray of their backing storage array will prevent the GC from collecting any of that backing array. This is a memory leak.\n* Slices that share a backing array can mess with each other. Remember a slice is just a descriptor with a pointer, but the backing storage can be mutably modified underneath multiple descriptors."
    }
  ]
}