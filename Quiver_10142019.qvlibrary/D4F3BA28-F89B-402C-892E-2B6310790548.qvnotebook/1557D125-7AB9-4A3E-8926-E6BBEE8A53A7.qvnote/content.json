{
  "title": "Envoy - Jet",
  "cells": [
    {
      "type": "markdown",
      "data": "### ANSWER ME\n* How does Envoy route traffic at Jet?\n* How do we manage service discovery?\n* How do we manage certificates in Envoy?\n* What filters do we run on our HTTP listener?\n* What is Envoy's Outlier Detection?\n* What runs on an Ansible-provisioned Envoy node?\n* How does Batman's auth flow for Envoy fit in?\n---\n\n_How does Envoy route traffic at Jet?_\n> Three ways: \n> 1) **AutoProxy** - add the appropriate proxy tag to your deploy manifest and routing starts\n> 2) **Phaser** - blue/green deploys, percentage-based traffic splitting, canary deploys, etc.\n> 3) **Thor Routing** - static Consul routing data used for Thor FC routing, separate from Phaser. See more below. This can also be used hypothetically for cluster overrides and more.\n\n_How do we manage service discovery?_\n> Nebula is our implementation of a control plane for Envoy's xDS APIs; more specifically, Nebula implements the ADS (aggregated) API for clusters, routes, and endpoints. Future work pending for listeners and secrets.\n\n_How do we manage certificates in Envoy?_\n> Certificates are currently configured statically via Ansible. The certificate creation process is managed via Rocket Skates, which uses LetsEncrypt behind the scenes. Rocket Skates Agents are deployed via Ansible on each Envoy node; these agents then watch Consul KV paths for \"roles\" that define what certificates to pull down on each node. The Agents will pull down those certs if they exist.\n\n_What filters do we run on our HTTP listener?_\n> In order:\n> 1) [Optional GZip Compression](https://www.envoyproxy.io/docs/envoy/latest/configuration/http_filters/gzip_filter) -- this is only hit based on the presence of certain \"encoding\" headers.\n> 2) [HTTP Healthcheck](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/health_checking) -- we use this in \"no passthrough\" mode, which means we only return 503s if the listener is draining (due to LDS pushes, restarts, or manual healthcheck fails). In this mode, the actual upstreams are not checked for health -- it's just Envoy.\n> 3) [ext-authz](https://www.envoyproxy.io/docs/envoy/latest/configuration/http_filters/ext_authz_filter) -- we can flip this on and off via Ansible group_vars per env. It's set up to hit `batman-introspection-go.service.consul`, which is Batman's auth server.\n\n----\n### REMEMBER ME\n\n**xDS Ordering**\n> [CDS, EDS, LDS, RDS] is the best ordering for minimizing consistency issues between discovery endpoints. v2 APIs are eventually consistent and independent of one another. Either use ADS (aggregated discovery service) or implement your management service with strong ordering guarantees. If RDS references some cluster that CDS hasn't heard about yet, those routes will be ignored.\n\n**Route-Specific Envoy Config**\n> We have route-specific Envoy config in Consul for routing changes, extra headers, direct responses, etc.\n> \n> _This is all separate from Phaser!!_\n>\n> For example, Thor uses this for all of their services to route general traffic to FC-specific services. This does a RegEx on the request URL to detect things like `/.../fc000/...`, which will then route to some `https://...-fc000.jet.network/...` service instance.\n>\n> [Example](http://consul.qa.jet.com:8500/ui/qa/kv/guardians/envoy/envoy.eastus2.corp-qa.jet.network/default/routes/thor-heimdall-api/edit)\n>\n> This all lives in Consul KV under `guardians/envoy/<your-dc>/default/routes`. Not sure what the `cluster` part corresponds to.\n\n"
    }
  ]
}